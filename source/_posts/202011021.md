---
title: 安装eslint
date: 2020-11-02 15:11:52
tags: [eslint]
---
### 使用NPM/Yarn进行安装
```js
# npm
$ npm install eslint -g

# yarn
$ yarn global add eslint
```
使用eslint -v检测是否下载成功
### 生成规则配置文件
```js
# eslint --init
```
### 生成方式
1. Answer questions about your style* 通过回答问题来生成规则文件

2. Use a popular style guide* 使用已经配置好的流行的规则(个人推荐)

3. Inspect your JavaScript file(s)* 检查现有的JavaScript文件来自动生成

选择选项1后，ESLint会询问你一系列问题，来自动生成规则文件。

选择选项2 后，会让你选择一个规则来源，默认提供3个，分别是Google， Airbnb和Standard。后面的地址是规范的内容。
* Airbnb (https://github.com/airbnb/javascript) 
* Standard (https://github.com/standard/standard) 
* Google (https://github.com/google/eslint-config-google) 

选择选项3后，会以一些交互式的问题开始，问题包含选择1的前面部分，然后可以选择JavaScript文件或者目录来进行代码风格检测，再根据检测的结果来生成配置文件(包含大量规则)。

*****
### Airbnb JavaScript Style Guide()
### Types
1.1 基本类型:当您访问一个基本类型时，您可以直接处理它的值。
* string
* number
* boolean
* null
* undefined
* symbol
* bigint
```js 
const foo = 1;
let bar = foo;

bar = 9;
console.log(foo, bar); // => 1, 9
```
> Symbols和BigInt在一些浏览器中是不支持的，应在兼容的浏览器中使用

#### 1.2 复杂类型:当您访问复杂类型时，您应处理对其值的引用。
* object
* array
* function
```js
const foo = [1, 2];
const bar = foo;

bar[0] = 9;
console.log(foo[0], bar[0]); // => 9, 9
```

### References
#### 2.1 引用数据应该使用const不应该用var声明. eslint: prefer-const, no-const-assign
```js
// bad
var a = 1;
var b = 2;

// good
const a = 1;
const b = 2;
```

#### 2.2 如果必须重新分配引用，请使用let而不是var. eslint: no-var
```js
// bad
var count = 1;
if (true) {
  count += 1;
}

// good, use the let.
let count = 1;
if (true) {
  count += 1;
}
```

#### 2.3 注意，let和const都是块作用域的
```js
// const and let only exist in the blocks they are defined in.
{
  let a = 1;
  const b = 1;
}
console.log(a); // ReferenceError
console.log(b); // ReferenceError
```

### Objects
#### 3.1 使用字面语法创建对象. eslint: no-new-object
```js
// bad
const item = new Object();

// good
const item = {};
```
#### 3.2 在创建具有动态属性名的对象时使用计算属性名.
```js
function getKey(k) {
  return `a key named ${k}`;
}

// bad
const obj = {
  id: 5,
  name: 'San Francisco',
};
obj[getKey('enabled')] = true;

// good
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true,
};
```
> 它们允许您在一个地方定义对象的所有属性。

#### 3.3 使用便捷的对象方法. eslint: object-shorthand
```js
// bad
const atom = {
  value: 1,

  addValue: function (value) {
    return atom.value + value;
  },
};

// good
const atom = {
  value: 1,

  addValue(value) {
    return atom.value + value;
  },
};
```

#### 3.4 使用属性值缩写。eslint: object-shorthand
```js
const lukeSkywalker = 'Luke Skywalker';

// bad
const obj = {
  lukeSkywalker: lukeSkywalker,
};

// good
const obj = {
  lukeSkywalker,
};
```

#### 3.5 在对象声明的开头对快捷属性进行分组。
```
const anakinSkywalker = 'Anakin Skywalker';
const lukeSkywalker = 'Luke Skywalker';

// bad
const obj = {
  episodeOne: 1,
  twoJediWalkIntoACantina: 2,
  lukeSkywalker,
  episodeThree: 3,
  mayTheFourth: 4,
  anakinSkywalker,
};

// good
const obj = {
  lukeSkywalker,
  anakinSkywalker,
  episodeOne: 1,
  twoJediWalkIntoACantina: 2,
  episodeThree: 3,
  mayTheFourth: 4,
};
```
> 使用简写更容易区分哪些属性。

#### 3.6 只引用无效标识符的引号属性。eslint: quote-props
```js
// bad
const bad = {
  'foo': 3,
  'bar': 4,
  'data-blah': 5,
};

// good
const good = {
  foo: 3,
  bar: 4,
  'data-blah': 5,
};
```

#### 3.7 不要调用Object。直接原型方法，如hasOwnProperty、propertyIsEnumerable和isPrototypeOf。eslint: no-prototype-builtins
```js
// bad
console.log(object.hasOwnProperty(key));

// good
console.log(Object.prototype.hasOwnProperty.call(object, key));

// best
const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.
console.log(has.call(object, key));
/* or */
import has from 'has'; // https://www.npmjs.com/package/has
console.log(has(object, key));
```
> 这些方法可能被问题对象的属性隐藏-考虑{hasOwnProperty: false} -或者，该对象可能是一个空对象(object .create(null))。

#### 使用对象扩展操作符胜于对象。赋给浅拷贝对象。使用对象rest操作符来获得省略了某些属性的新对象。eslint: prefer-object-spread
```js
// very bad
const original = { a: 1, b: 2 };
const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ
delete copy.a; // so does this

// bad
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 };
const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy; // noA => { b: 2, c: 3 }
```

### Arrays
#### 4.1 使用字面语法创建数组. eslint: no-array-constructor
```js
// bad
const items = new Array();

// good
const items = [];
```

#### 4.2 使用数组#push而不是直接赋值来向数组添加项.
```js
const someStack = [];

// bad
someStack[someStack.length] = 'abracadabra';

// good
someStack.push('abracadabra');
```

#### 4.3 使用array spreads…复制数组.
```js
// bad
const len = items.length;
const itemsCopy = [];
let i;

for (i = 0; i < len; i += 1) {
  itemsCopy[i] = items[i];
}

// good
const itemsCopy = [...items];
```

#### 4.4 要将一个可迭代对象转换为数组，请使用spread…而不是Array.from.
```js
const foo = document.querySelectorAll('.foo');

// good
const nodes = Array.from(foo);

// best
const nodes = [...foo];
```

#### 4.5 使用array. from将类数组对象转换为数组。
```js
const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };

// bad
const arr = Array.prototype.slice.call(arrLike);

// good
const arr = Array.from(arrLike);
```

#### 4.6 使用arrayfrom而不是spread…用于遍历映射，因为它避免创建中间数组
```js
// bad
const baz = [...foo].map(bar);

// good
const baz = Array.from(foo, bar);
```

#### 4.7 在数组方法回调中使用return语句。如果函数体由一条语句组成，返回一个没有副作用的表达式，那么省略返回值是可以的。eslint: array-callback-return
```js
// good
[1, 2, 3].map((x) => {
  const y = x + 1;
  return x * y;
});

// good
[1, 2, 3].map((x) => x + 1);

// bad - no returned value means `acc` becomes undefined after the first iteration
[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) => {
  const flatten = acc.concat(item);
});

// good
[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) => {
  const flatten = acc.concat(item);
  return flatten;
});

// bad
inbox.filter((msg) => {
  const { subject, author } = msg;
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee';
  } else {
    return false;
  }
});

// good
inbox.filter((msg) => {
  const { subject, author } = msg;
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee';
  }

  return false;
});
```

#### 4.8 如果数组有多行，在数组的开括号和闭括号之前使用换行符
```js
// bad
const arr = [
  [0, 1], [2, 3], [4, 5],
];

const objectInArray = [{
  id: 1,
}, {
  id: 2,
}];

const numberInArray = [
  1, 2,
];

// good
const arr = [[0, 1], [2, 3], [4, 5]];

const objectInArray = [
  {
    id: 1,
  },
  {
    id: 2,
  },
];

const numberInArray = [
  1,
  2,
];
```

### Destructuring
#### 5.1 当访问和使用一个对象的多个属性时，使用对象析构。eslint: prefer-destructuring
```js
// bad
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;

  return `${firstName} ${lastName}`;
}

// good
function getFullName(user) {
  const { firstName, lastName } = user;
  return `${firstName} ${lastName}`;
}

// best
function getFullName({ firstName, lastName }) {
  return `${firstName} ${lastName}`;
}
```

#### 5.2 使用数组析构。eslint: prefer-destructuring 
```
const arr = [1, 2, 3, 4];

// bad
const first = arr[0];
const second = arr[1];

// good
const [first, second] = arr;
```

#### 5.3 对多个返回值使用对象解构，而不是数组解构。
```js
// bad
function processInput(input) {
  // then a miracle occurs
  return [left, right, top, bottom];
}

// the caller needs to think about the order of return data
const [left, __, top] = processInput(input);

// good
function processInput(input) {
  // then a miracle occurs
  return { left, right, top, bottom };
}

// the caller selects only the data they need
const { left, top } = processInput(input);
```

### Strings
#### 6.1 对字符串使用单引号. eslint: quotes
```js
// bad
const name = "Capt. Janeway";

// bad - template literals should contain interpolation or newlines
const name = `Capt. Janeway`;

// good
const name = 'Capt. Janeway';
```

#### 6.2 导致一行超过100个字符的字符串不应该使用字符串连接跨多行写入.
```js
// bad
const errorMessage = 'This is a super long error that was thrown because \
of Batman. When you stop to think about how Batman had anything to do \
with this, you would get nowhere \
fast.';

// bad
const errorMessage = 'This is a super long error that was thrown because ' +
  'of Batman. When you stop to think about how Batman had anything to do ' +
  'with this, you would get nowhere fast.';

// good
const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';
```

#### 6.3 当以编程方式构建字符串时，使用模板字符串而不是连接。eslint: prefer-template template-curly-spacing
```js
// bad
function sayHi(name) {
  return 'How are you, ' + name + '?';
}

// bad
function sayHi(name) {
  return ['How are you, ', name, '?'].join();
}

// bad
function sayHi(name) {
  return `How are you, ${ name }?`;
}

// good
function sayHi(name) {
  return `How are you, ${name}?`;
}
```

#### 6.5 永远不要在字符串上使用eval()，它会打开太多的漏洞。eslint: no-eval
#### 6.6 不要对字符串中的字符进行不必要的转义。eslint: no-useless-escape
```js
// bad
const foo = '\'this\' \i\s \"quoted\"';

// good
const foo = '\'this\' is "quoted"';
const foo = `my name is '${name}'`;
```

### Functions
#### 7.1 使用命名函数表达式，而不是函数声明。eslint: func-style
```js
// bad
function foo() {
  // ...
}

// bad
const foo = function () {
  // ...
};

// good
// lexical name distinguished from the variable-referenced invocation(s)
const short = function longUniqueMoreDescriptiveLexicalFoo() {
  // ...
};
```
#### 7.2将立即调用的函数表达式用括号括起来. eslint: wrap-iife
```js
// immediately-invoked function expression (IIFE)
(function () {
  console.log('Welcome to the Internet. Please follow me.');
}());
```
#### 7.3 永远不要在非函数块(if, while等)中声明函数。将函数赋值给一个变量。浏览器允许您这样做，但它们都有不同的解释，这是坏消息。eslint: no-loop-func

#### 7.4 注意: ECMA-262将一个块定义为语句列表, 函数声明不是语句
```js
// bad
if (currentUser) {
  function test() {
    console.log('Nope.');
  }
}

// good
let test;
if (currentUser) {
  test = () => {
    console.log('Yup.');
  };
}
```

#### 7.5 永远不要给参数命名为实参。这将优先于给每个函数作用域的arguments对象。
```js
// bad
function foo(name, options, arguments) {
  // ...
}

// good
function foo(name, options, args) {
  // ...
}
```

#### 7.6 永远不要使用参数，选择使用rest语法…代替。eslint: prefer-rest-params
```js
// bad
function concatenateAll() {
  const args = Array.prototype.slice.call(arguments);
  return args.join('');
}

// good
function concatenateAll(...args) {
  return args.join('');
}
```

#### 7.7 使用默认参数语法，而不是改变函数参数。
```js
// really bad
function handleThings(opts) {
  // No! We shouldn’t mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.
  opts = opts || {};
  // ...
}

// still bad
function handleThings(opts) {
  if (opts === void 0) {
    opts = {};
  }
  // ...
}

// good
function handleThings(opts = {}) {
  // ...
}
```

#### 7.8 避免使用默认参数的副作用.
```js
var b = 1;
// bad
function count(a = b++) {
  console.log(a);
}
count();  // 1
count();  // 2
count(3); // 3
count();  // 3
```

#### 7.9 总是把默认参数放在最后. eslint: default-param-last
```js
// bad
function handleThings(opts = {}, name) {
  // ...
}

// good
function handleThings(name, opts = {}) {
  // ...
}
```

#### 7.10 不要使用函数构造函数来创建新函数。eslint: no-new-func
```js
// bad
var add = new Function('a', 'b', 'return a + b');

// still bad
var subtract = Function('a', 'b', 'return a - b');
```

#### 7.11 函数签名中的空格。eslint: space-before-function-paren space-before-blocks
```js
// bad
const f = function(){};
const g = function (){};
const h = function() {};

// good
const x = function () {};
const y = function a() {};
```

#### 7.12 不要改变参数。eslint: no-param-reassign
```js
// bad
function f1(obj) {
  obj.key = 1;
}

// good
function f2(obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;
}
```
#### 7.13 不要重新分配参数。eslint: no-param-reassign
```js
// bad
function f1(a) {
  a = 1;
  // ...
}

function f2(a) {
  if (!a) { a = 1; }
  // ...
}

// good
function f3(a) {
  const b = a || 1;
  // ...
}

function f4(a = 1) {
  // ...
}
```
#### 7.14 更喜欢使用扩展操作符…调用变元函数。eslint: prefer-spread
```js
// bad
const x = [1, 2, 3, 4, 5];
console.log.apply(console, x);

// good
const x = [1, 2, 3, 4, 5];
console.log(...x);

// bad
new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));

// good
new Date(...[2016, 8, 5]);
```

#### 7.15 具有多行签名或调用的函数应该像本指南中其他的多行列表一样缩进:每一项单独在一行中，最后一项后面有逗号。eslint: function-paren-newline
```js
// bad
function foo(bar,
             baz,
             quux) {
  // ...
}

// good
function foo(
  bar,
  baz,
  quux,
) {
  // ...
}

// bad
console.log(foo,
  bar,
  baz);

// good
console.log(
  foo,
  bar,
  baz,
);
```
### Arrow Functions
#### 8.1 当你必须使用匿名函数(比如传递内联回调函数)时，使用箭头函数表示法。eslint: prefer-arrow-callback arrow-spacing 
```js
// bad
[1, 2, 3].map(function (x) {
  const y = x + 1;
  return x * y;
});

// good
[1, 2, 3].map((x) => {
  const y = x + 1;
  return x * y;
});
```

#### 8.2 如果函数体由一条语句组成，返回一个没有副作用的表达式，则省略大括号并使用隐式返回。否则，保持大括号并使用return语句。eslint: arrow-parens arrow-body-style
```js
// bad
[1, 2, 3].map((number) => {
  const nextNumber = number + 1;
  `A string containing the ${nextNumber}.`;
});

// good
[1, 2, 3].map((number) => `A string containing the ${number + 1}.`);

// good
[1, 2, 3].map((number) => {
  const nextNumber = number + 1;
  return `A string containing the ${nextNumber}.`;
});

// good
[1, 2, 3].map((number, index) => ({
  [index]: number,
}));

// No implicit return with side effects
function foo(callback) {
  const val = callback();
  if (val === true) {
    // Do something if callback returns true
  }
}

let bool = false;

// bad
foo(() => bool = true);

// good
foo(() => {
  bool = true;
});
```

#### 8.3 如果表达式跨越多行，可以用括号括起来以提高可读性.
```js
// bad
['get', 'post', 'put'].map((httpMethod) => Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod,
  )
);

// good
['get', 'post', 'put'].map((httpMethod) => (
  Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod,
  )
));
```

#### 8.4 为了清晰和一致性，总是在参数周围加上括号。eslint: arrow-parens
```js
// bad
[1, 2, 3].map(x => x * x);

// good
[1, 2, 3].map((x) => x * x);

// bad
[1, 2, 3].map(number => (
  `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`
));

// good
[1, 2, 3].map((number) => (
  `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`
));

// bad
[1, 2, 3].map(x => {
  const y = x + 1;
  return x * y;
});

// good
[1, 2, 3].map((x) => {
  const y = x + 1;
  return x * y;
});
```

#### 8.5 避免将箭头函数语法(=>)与比较运算符(<=，>=)混淆。eslint: no-confusing-arrow
```js
// bad
const itemHeight = (item) => item.height <= 256 ? item.largeSize : item.smallSize;

// bad
const itemHeight = (item) => item.height >= 256 ? item.largeSize : item.smallSize;

// good
const itemHeight = (item) => (item.height <= 256 ? item.largeSize : item.smallSize);

// good
const itemHeight = (item) => {
  const { height, largeSize, smallSize } = item;
  return height <= 256 ? largeSize : smallSize;
};
```

#### 8.6 强制使用隐式返回的箭头函数体的位置。eslint: implicit-arrow-linebreak
```js
// bad
(foo) =>
  bar;

(foo) =>
  (bar);

// good
(foo) => bar;
(foo) => (bar);
(foo) => (
   bar
)
```

### Classes & Constructors
#### 9.1 始终使用类。避免直接操作原型.
```js
// bad
function Queue(contents = []) {
  this.queue = [...contents];
}
Queue.prototype.pop = function () {
  const value = this.queue[0];
  this.queue.splice(0, 1);
  return value;
};

// good
class Queue {
  constructor(contents = []) {
    this.queue = [...contents];
  }
  pop() {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
  }
}
```
> 类语法更简洁，更容易推理。

#### 9.2使用extends扩展。
```js
// bad
const inherits = require('inherits');
function PeekableQueue(contents) {
  Queue.apply(this, contents);
}
inherits(PeekableQueue, Queue);
PeekableQueue.prototype.peek = function () {
  return this.queue[0];
};

// good
class PeekableQueue extends Queue {
  peek() {
    return this.queue[0];
  }
}
```

#### 9.3 方法可以返回此值来帮助进行方法链接.
```js
// bad
Jedi.prototype.jump = function () {
  this.jumping = true;
  return true;
};

Jedi.prototype.setHeight = function (height) {
  this.height = height;
};

const luke = new Jedi();
luke.jump(); // => true
luke.setHeight(20); // => undefined

// good
class Jedi {
  jump() {
    this.jumping = true;
    return this;
  }

  setHeight(height) {
    this.height = height;
    return this;
  }
}

const luke = new Jedi();

luke.jump()
  .setHeight(20);
```

#### 9.4 编写一个自定义的toString()方法是可以的，只要确保它能成功工作并且没有副作用。
```js
class Jedi {
  constructor(options = {}) {
    this.name = options.name || 'no name';
  }

  getName() {
    return this.name;
  }

  toString() {
    return `Jedi - ${this.getName()}`;
  }
}
```
#### 9.5 如果没有指定类，则类有一个默认构造函数。没有必要使用空的构造函数或只委托给父类的构造函数。eslint: no-useless-constructor
```js
// bad
class Jedi {
  constructor() {}

  getName() {
    return this.name;
  }
}

// bad
class Rey extends Jedi {
  constructor(...args) {
    super(...args);
  }
}

// good
class Rey extends Jedi {
  constructor(...args) {
    super(...args);
    this.name = 'Rey';
  }
}
```

#### 9.6 避免重复的班级成员. eslint: no-dupe-class-members
```js
// bad
class Foo {
  bar() { return 1; }
  bar() { return 2; }
}

// good
class Foo {
  bar() { return 1; }
}

// good
class Foo {
  bar() { return 2; }
}
```

#### 9.7 除非外部库或框架需要使用特定的非静态方法，否则类方法应该使用`this`或将其转换为静态方法。作为一个实例方法，应该表明它的行为因接收方的属性而不同。eslint: class-methods-use-this
```js
// bad
class Foo {
  bar() {
    console.log('bar');
  }
}

// good - this is used
class Foo {
  bar() {
    console.log(this.bar);
  }
}

// good - constructor is exempt
class Foo {
  constructor() {
    // ...
  }
}

// good - static methods aren't expected to use this
class Foo {
  static bar() {
    console.log('bar');
  }
}
```

### Modules
#### 10.1在非标准模块系统上总是使用模块(导入/导出)。您总是可以转到您喜欢的模块系统。
```js
// bad
const AirbnbStyleGuide = require('./AirbnbStyleGuide');
module.exports = AirbnbStyleGuide.es6;

// ok
import AirbnbStyleGuide from './AirbnbStyleGuide';
export default AirbnbStyleGuide.es6;

// best
import { es6 } from './AirbnbStyleGuide';
export default es6;
```

#### 10.2 不要使用通配符导入.
```js
// bad
import * as AirbnbStyleGuide from './AirbnbStyleGuide';

// good
import AirbnbStyleGuide from './AirbnbStyleGuide';
```
> 这确保您有一个默认导出

#### 10.3 不直接从导入导出。
```js
// bad
// filename es6.js
export { es6 as default } from './AirbnbStyleGuide';

// good
// filename es6.js
import { es6 } from './AirbnbStyleGuide';
export default es6;
```
> 尽管单行程序很简洁，但是拥有一种清晰的导入方法和一种清晰的导出方法可以使事情保持一致

#### 10.4 只从一个位置的路径导入。eslint: no-duplicate-imports
```js
// bad
import foo from 'foo';
// … some other imports … //
import { named1, named2 } from 'foo';

// good
import foo, { named1, named2 } from 'foo';

// good
import foo, {
  named1,
  named2,
} from 'foo';
```

#### 10.5 不要导出可变绑定。eslint:import/ no-mutable-exports
```js
// bad
let foo = 3;
export { foo };

// good
const foo = 3;
export { foo };
```

#### 10.6 在只有一个导出的模块中，最好选择默认导出而不是指定导出。eslint:import/ prefer-default-export
```js
// bad
export function foo() {}

// good
export default function foo() {}
```

#### 10.7 将所有导入置于非导入声明之上。eslint: import/first
```js
// bad
import foo from 'foo';
foo.init();

import bar from 'bar';

// good
import foo from 'foo';
import bar from 'bar';

foo.init();
```

#### 10.8 多行导入应该像多行数组和对象文字一样缩进。eslint: object-curly-newline
```js
// bad
import {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';

// good
import {
  longNameA,
  longNameB,
  longNameC,
  longNameD,
  longNameE,
} from 'path';
```

#### 10.9 在模块导入语句中不允许Webpack加载器语法. eslint: import/no-webpack-loader-syntax
```js
// bad
import fooSass from 'css!sass!foo.scss';
import barCss from 'style!css!bar.css';

// good
import fooSass from 'foo.scss';
import barCss from 'bar.css';
```

#### 10.10 不包括JavaScript文件名扩展名eslint: import/extensions
```js
// bad
import foo from './foo.js';
import bar from './bar.jsx';
import baz from './baz/index.jsx';

// good
import foo from './foo';
import bar from './bar';
import baz from './baz';
```

### Iterators and Generators
#### 11.1 不要使用迭代器。像JavaScript的高阶函数，而不是像for-in或for-of这样的循环。eslint: no-iterator no-restricted-syntax
> Use map() / every() / filter() / find() / findIndex() / reduce() / some() / ... to iterate over arrays, and Object.keys() / Object.values() / Object.entries() to produce arrays so you can iterate over objects.
```js
const numbers = [1, 2, 3, 4, 5];

// bad
let sum = 0;
for (let num of numbers) {
  sum += num;
}
sum === 15;

// good
let sum = 0;
numbers.forEach((num) => {
  sum += num;
});
sum === 15;

// best (use the functional force)
const sum = numbers.reduce((total, num) => total + num, 0);
sum === 15;

// bad
const increasedByOne = [];
for (let i = 0; i < numbers.length; i++) {
  increasedByOne.push(numbers[i] + 1);
}

// good
const increasedByOne = [];
numbers.forEach((num) => {
  increasedByOne.push(num + 1);
});

// best (keeping it functional)
const increasedByOne = numbers.map((num) => num + 1);
```

#### 11.2 不要使用generators
> 它们不能很好地转化为ES5

#### 11.3 如果你必须使用生成器，或者如果你无视我们的建议，确保它们的函数签名间隔正确。eslint: generator-star-spacing
```js
// bad
function * foo() {
  // ...
}

// bad
const bar = function * () {
  // ...
};

// bad
const baz = function *() {
  // ...
};

// bad
const quux = function*() {
  // ...
};

// bad
function*foo() {
  // ...
}

// bad
function *foo() {
  // ...
}

// very bad
function
*
foo() {
  // ...
}

// very bad
const wat = function
*
() {
  // ...
};

// good
function* foo() {
  // ...
}

// good
const foo = function* () {
  // ...
};
```