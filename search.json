[{"title":"学习Vue遇到的问题汇总","url":"/2021/02/20/vue/xue-xi-vue-yu-dao-de-wen-ti-hui-zong/","content":"\n一、 解析DOM模板时的注意事项\n\n有些 HTML 元素，诸如 `<ul>`、`<ol>`、`<table>` 和 `<select>`，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 `<li>`、`<tr>` 和 `<option>`，只能出现在其它某些特定的元素内部。\n\n<!-- more -->\n\n这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：\n```js\n<table>\n  <tr-item></tr-item>\n</table>\n```\n这个自定义组件`<tr-item>`会被作为无效的内容提升到外部，并导致最终渲染结果出错。\n\n![](1.png)\n\n幸好这个特殊的 is attribute 给了我们一个变通的办法：\n```js\n<table>\n  <tr is=\"tr-item\"></tr>\n</table>\n```\n\n需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：\n- 字符串 (例如：template: '...')\n- 单文件组件 (.vue)\n- `<script type=\"text/x-template\">`\n\n例如:\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Vue解析DOM模板时的注意事项</title>\n    <script src=\"https://cdn.staticfile.org/vue/2.4.2/vue.min.js\"></script>\n    <script type=\"text/x-template\" id=\"todo-four\">\n      <table><tr-item></tr-item></table>\n    </script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <p>方式一：直接在table下使用子组件,会出错，子元素跳级 tr 和 table 同级</p>\n      <table>\n        <tr-item></tr-item>\n      </table>\n      <hr />\n      <p>\n        方式二: is=\"\" 的方式可以避开一些潜在的浏览器 **解析规则** ，正确渲染元素\n      </p>\n      <table>\n        <tr is=\"tr-item\"></tr>\n      </table>\n      <p>方式三：通过template字符串</p>\n      <todo-three></todo-three>\n      <hr />\n      <p>\n        方式四：通过<i><</i>script type=\"text/x-template\"\n        id=\"todo-four\"><i><</i>/script>\n      </p>\n      <todo-four></todo-four>\n    </div>\n    <script type=\"text/javascript\">\n      Vue.component(\"tr-item\", {\n        template: \"<tr>通过控制台查看我是否正确渲染</tr>\"\n      });\n      Vue.component(\"todo-four\", {\n        template: \"#todo-four\"\n      });\n      const vm = new Vue({\n        el: \"#app\",\n        components: {\n          \"todo-three\": {\n            template: \"<table><tr-item></tr-item></table>\"\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n```\n","tags":["vue"]},{"title":"Chrome浏览器安装Vue插件方法","url":"/2021/02/19/chrome-liu-lan-qi-an-zhuang-vue-cha-jian-fang-fa/","content":"\n1. 首先去github下载vue.zip文件插件下载地址：https://github.com/vuejs/vue-devtools\n```js\ngit clone https://github.com/vuejs/vue-devtools.git vue-devtools\n```\n\n2. 查看当前分支是不是master分支, 如果不是切换到master分支\n```js\ngit checkout master\n```\n\n3. 下载cnpm,因为vue插件要通过cnpm下载\n```js\nnpm install -g cnpm -registry=https://registry.npm.taobao.org\n```\n\n4. 定位到刚才下载的vue插件目录里，之后输入`cnpm install`安装依赖\n\n5. 通过`npm run build`编译\n\n6. 接着修改manifest.json 里persistent 字段为true\n\n7. 在Chrome中打开地址`chrome://extensions/`  将vue-devtools-dev\\shells\\chrome文件夹拖入Chrome中\n\n至此插件才算安装完成\n\n","tags":["工具"]},{"title":"你不知道的JavaScript--this调用机制","url":"/2021/01/16/javascript/this-diao-yong-ji-zhi/","content":"\n### this是什么\n\n当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。\n\n作用：this是JavaScript的一种机制， this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。\n\nthis的上下文取决于函数调用时的各种条件。 this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n<!--more-->\n\n### 调用位置\n\n在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？\n\n例1:\n```js\nfunction baz() {\n  // 当前调用栈是：baz\n  // 因此，当前调用位置是全局作用域\n  console.log( \"baz\" );\n  bar(); // <-- bar 的调用位置\n}\n\nfunction bar() {\n  // 当前调用栈是 baz -> bar\n  // 因此，当前调用位置在 baz 中\n  console.log( \"bar\" );\n  foo(); // <-- foo 的调用位置\n}\n\nfunction foo() {\n  // 当前调用栈是 baz -> bar -> foo\n  // 因此，当前调用位置在 bar 中\n  console.log( \"foo\" );\n}\n\nbaz(); // <-- baz 的调用位置\n```\n\n### this的绑定规则\n\n#### 1. 默认绑定\n\n例2:\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar a = 2;\nfoo(); // 2\n```\n在例2中可以看到当调用 `foo()` 时, 在`foo()`前面没有任何的对象调用该函数，从而把`this`绑定到全局对象或`undefined`上(取决于是否是严格模式)，这种绑定到全局对象的方式就是`默认绑定`。\n\n> 注意<br>\n> 在严格模式下( strict mode )，全局的 `this`会绑定到 undefined\n\n#### 2. 隐式绑定\n\n例3:\n```js\nfunction foo() {\n  console.log( this.a );\n}\n\nvar obj = {\n  a: 2,\n  foo: foo\n};\nobj.foo(); // 2\n```\n在例3中，在`foo()`前面有调用对象且`this`默认指向该对象的方式就是`隐式绑定`。\n\n例4:\n```js\nfunction foo() {\n  console.log( this.a );\n}\nvar obj2 = {\n  a: 42,\n  foo: foo\n};\nvar obj1 = {\n  a: 2,\n  obj2: obj2\n};\nobj1.obj2.foo(); // 42\n```\n在例4中可以看出对象属性引用链中只有最顶层或者说最后一层会影响调用位置。\n\n隐式丢失\n\n一个最常见的 `this` 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 `this` 绑定到全局对象或者 `undefined` 上，取决于是否是严格模式。\n\n例5:\n```js\nfunction foo() {\n  console.log( this.a );\n}\nvar obj = {\n  a: 2,\n  foo: foo\n};\nvar bar = obj.foo; // 函数别名！\nvar a = \"oops, global\"; // a 是全局对象的属性\nbar(); // \"oops, global\"\n```\n在例5中，虽然 `bar` 是 `obj.foo` 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的`bar()` 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n\n一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：\n例6:\n```js\nfunction foo() {\n  console.log( this.a );\n}\nfunction doFoo(fn) {\n  // fn 其实引用的是 foo\n  fn(); // <-- 调用位置！\n}\nvar obj = {\n  a: 2,\n  foo: foo\n};\nvar a = \"oops, global\"; // a 是全局对象的属性\ndoFoo( obj.foo ); // \"oops, global\"\n```\n\n如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：\n\n例7:\n```js\nfunction foo() {\n  console.log( this.a );\n}\nvar obj = {\n  a: 2,\n  foo: foo\n};\nvar a = \"oops, global\"; // a 是全局对象的属性\nsetTimeout( obj.foo, 100 ); // \"oops, global\"\n```\nJavaScript 环境中内置的 `setTimeout()` 函数实现和下面的伪代码类似：\n\n例8:\n```js\nfunction setTimeout(fn,delay) {\n  // 等待 delay 毫秒\n  fn(); // <-- 调用位置！\n}\n```\n\n#### 3. 显式绑定\n\n例9:\n```js\nfunction foo() {\n  console.log( this.a );\n}\nvar obj = {\n  a:2\n};\nfoo.call( obj ); // 2\n```\n在例9中，通过 `foo.call(..)` ，我们可以在调用 `foo` 时强制把它的 `this` 绑定到 `obj` 上, 这种可以直接指定 `this` 的绑定对象的方式就是`显式绑定`。\n\n> 注意<br>\n> 1.如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为“装箱”。<br>\n> 2.显式绑定仍然无法解决我们之前提出的丢失绑定问题\n\n可以改变this的内置函数有:\n- call\n- apply\n- bind\n\n硬绑定(显式绑定变种)\n\n作用: 防止丢失绑定问题\n缺点：绑定之后不能通过显式绑定或隐式绑定改变this\n\n硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：\n```js\nfunction foo(something) {\n  console.log( this.a, something );\n  return this.a + something;\n}\nvar obj = {\n  a:2\n};\nvar bar = function() {\n  return foo.apply( obj, arguments );\n};\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n另一种使用方法是创建一个 i 可以重复使用的辅助函数：\n```js\nfunction foo(something) {\n  console.log( this.a, something );\n  return this.a + something;\n}\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n  return function() {\n    return fn.apply( obj, arguments );\n  };\n}\nvar obj = {\n  a:2\n};\nvar bar = bind( foo, obj );\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.\nbind\n- bind()函数\n\n有两种实现bind的方法，下面第一种不支持使用new调用新创建的构造函数，而第二种支持:\n\n第一种：\n```js\n// Does not work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind) (function(){\n  Function.prototype.bind = function() {\n    var thatFunc = this;\n    var thatArg = [].slice.call(arguments, 1);\n    if (typeof thatFunc !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - ' +\n             'what is trying to be bound is not callable');\n    }\n    return function(){\n      return thatFunc.apply(thatArg, thatArg.concat.call(thatArg, arguments));\n    };\n  };\n})();\n```\n第二种：\n```js\n//  Yes, it does work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind) (function(){\n  Function.prototype.bind = function(otherThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var baseArgs = [].slice.call(arguments, 1);\n    var fToBind = this;\n    var fNOP = function() {};\n    var bound = function() {\n      return fToBind.apply(\n          fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs.concat.call(baseArgs, arguments);\n      );\n    };\n\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype;\n    }\n    fBound.prototype = new fNOP();\n\n    return bound;\n  };\n})();\n```\n\n软绑定\n\n作用： 软绑定就是在具有硬绑定相同的效果下，同时可以灵活的用显式绑定或隐式绑定修改this指向\n\n实现：\n```js\nFunction.prototype.softBind = function(obj) {\n  var fn = this;\n  // 捕获所有 curried 参数\n  var args = [].slice.call(arguments, 1);\n  var bound = function () {\n    // 改变this指向\n    return fn.apply(\n      !this || this === (window || global)? obj : this, \n      args.concat.apply(args, arguments)\n    );\n  }\n  bound.prototype = Object.create(fn.prototype);\n  return bound;\n}\n\nfunction show(){\n  console.log(this.name);\n}\n\nvar obj1 = {\n  name: 'Jhon'\n}\n\nvar obj2 = {\n  name: 'Kim'\n}\n\nvar show1 = show.softBind(obj1);\nshow1(); // => Jhon\nshow1.apply(obj2); // => Kim\nshow1(); // => Jhon\n```\n\n#### 4. new 绑定\n\n例10：\n```js\nfunction foo(a) {\n  this.a = a;\n}\nvar bar = new foo(2);\nconsole.log( bar.a ); // 2\n```\n使用 `new` 来调用 `foo(..)` 时，我们会构造一个新对象并把它绑定到 `foo(..)` 调用中的 this\n上。 `new` 是最后一种可以影响函数调用时 `this` 绑定行为的方法，我们称之为 `new 绑定`。\n\n使用 `new` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作\n1. 创建（或者说构造）一个全新的对象。\n2. 这个新对象会被执行 [[ 原型 ]] 连接。\n3. 这个新对象会绑定到函数调用的 this 。\n4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n实现new:\n```js\nFunction.prototype.createObject = function(){\n  // 创建（或者说构造）一个全新的对象\n  var newObj = {};\n  var args = [].shift.call(argments, 0);\n  // 这个新对象会被执行 [[ 原型 ]] 连接\n  newObj.__proto__ = args.prototype;\n  // 这个新对象会绑定到函数调用的 this\n  var result = args.apply(newObj, arguments);\n  // 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象\n  return typeof result === \"object\" ? result : newObj;\n}\n```\n\n#### 5. 优先级\n1. new 绑定\n2. 显式绑定\n3. 隐式绑定\n4. 默认绑定\n\n例11：\n```js\nfunction foo() {\n  console.log( this.a );\n}\nvar obj1 = {\n  a: 2,\n  foo: foo\n};\nvar obj2 = {\n  a: 3,\n  foo: foo\n};\nobj1.foo(); // 2\nobj2.foo(); // 3\nobj1.foo.call( obj2 ); // 3\nobj2.foo.call( obj1 ); // 2\n```\n从例11中可以看出显式绑定比隐式绑定优先级更高\n\n例12：\n```js\nfunction foo(something) {\n  this.a = something;\n}\nvar obj1 = {\n  foo: foo\n};\nvar obj2 = {};\nobj1.foo( 2 );\nconsole.log( obj1.a ); // 2\nobj1.foo.call( obj2, 3 );\nconsole.log( obj2.a ); // 3\nvar bar = new obj1.foo( 4 );\nconsole.log( obj1.a ); // 2\nconsole.log( bar.a ); // 4\n```\n从例12中可以看出new绑定比隐式绑定优先级更高\n\nnew 和 call / apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接\n进行测试。但是我们可以使用硬绑定来测试它俩的优先级。\n\n例13：\n```js\nfunction foo(something) {\n  this.a = something;\n}\nvar obj1 = {};\nvar bar = foo.bind( obj1 );\nbar( 2 );\nconsole.log( obj1.a ); // 2\nvar baz = new bar(3);\nconsole.log( obj1.a ); // 2\nconsole.log( baz.a ); // 3\n```\n从例13中可以看出 bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a修改为 3。相反， new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this 。因为使用了new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3, 所以new绑定比显式绑定优先级更高。\n\n> 总结：可以根据优先级来判断函数在某个调用位置应用的是哪条规则\n\n#### 间接引用\n例14：\n```js\nfunction foo() {\n  console.log( this.a );\n}\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n```\n赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是\np.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。\n\n#### 箭头函数\n\n箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决\n定 this。\n\n```js\nfunction foo() {\n  // 返回一个箭头函数\n  return (a) => {\n    //this 继承自 foo()\n    console.log( this.a );\n  };\n}\nvar obj1 = {\n  a:2\n};\nvar obj2 = {\n  a:3\n};\nvar bar = foo.call( obj1 );\nbar.call( obj2 ); // 2, 不是 3 ！\n```\nfoo() 内部创建的箭头函数会捕获调用时 foo() 的 this 。由于 foo() 的 this 绑定到 obj1 ，bar （引用箭头函数）的 this 也会绑定到 obj1 ，箭头函数的绑定无法被修改。（ new 也不\n行！）\n\n\n\n\n\n\n\n\n","tags":["book","javascript"]},{"title":"深入理解js this绑定","url":"/2020/11/02/javascript/shen-ru-li-jie-js-this-bang-ding/","content":"\n```javascript\nfunction foo(){\n  getName = function() {\n    console.log(1);\n  }\n  return this;\n}\n\nfoo.getName = function(){\n  console.log(2);\n}\n\nfoo.prototype.getName = function(){\n  console.log(3);\n}\n\nvar getName = function(){\n  console.log(4);\n}\n\nfunction getName(){\n  console.log(5);\n}\n\nfoo.getName(); // => 2\ngetName(); // => 4\nfoo().getName(); // => 1\ngetName(); // => 1\nnew foo.getName(); // => 2\nnew foo().getName(); // => 3\nnew new foo().getName(); // => 3\n```","tags":["eslint"]},{"title":"eslint安装笔记","url":"/2020/11/02/javascript/an-zhuang-eslint/","content":"### eslint\n","tags":["eslint"]},{"title":"visual studio code快捷键","url":"/2020/10/10/visual-studio-code-kuai-jie-jian/","content":"\n> ### General\n\n| 快捷键               | 描述                    | 中文               |\n| -------------------- | ----------------------- | ------------------ |\n| Ctrl + Shift + P, F1 | Show Command Palette    | 显示命令面板       |\n| Ctrl + P             | Quick Open, Go to File… | 快速打开，进入文件 |\n| Ctrl + Shift + N     | New window/instance     | 新窗口/实例        |\n| Ctrl+Shift+W         | Close window/instance   | 关闭窗口/实例      |\n| Ctrl +               | User Settings           | 用户设置           |\n| Ctrl + K Ctrl + S    | Keyboard Shortcuts      | 键盘快捷键         |\n<!-- more -->\n<br>\n\n> ### Basic editing\n\n| 快捷键               | 描述                               | 中文           |\n| -------------------- | ---------------------------------- | -------------- |\n| Ctrl + X             | Cut line (empty selection)         | 剪切           |\n| Ctrl + C             | Copy line (empty selection)        | 复制           |\n| Alt + ↑ / ↓          | Move line up/down                  | 向上/下移动行  |\n| Shift + Alt + ↓ / ↑  | Copy line up/down                  | 向上/下复制行  |\n| Ctrl + Shift + K     | Delete line                        | 删除行         |\n| Ctrl + Enter         | Insert line below                  | 在下面插入行   |\n| Ctrl + Shift + Enter | Insert line above                  | 在上面插入行   |\n| Ctrl + Shift + \\     | Jump to matching bracket           | 跳到匹配的括号 |\n| Ctrl + ] / [         | Indent/outdent line                | 行缩进         |\n| Home /               | End Go to beginning/end of line    | 转到行首/行尾  |\n| Ctrl + Home          | Go to beginning of file            | 转到文件的开头 |\n| Ctrl + End           | Go to end of file                  | 转到文件的结尾 |\n| Ctrl + ↑ / ↓         | Scroll line up/down                | 行上下滚动     |\n| Alt + PgUp / PgDn    | Scroll page up/down                | 页面上下滚动   |\n| Ctrl + Shift + [     | Fold (collapse) region             | 折叠           |\n| Ctrl + Shift + ]     | Unfold (uncollapse) region         | 展开           |\n| Ctrl + K Ctrl + [    | Fold (collapse) all subregions     | 折叠全部区域   |\n| Ctrl + K Ctrl + ]    | Unfold (uncollapse) all subregions | 展开全部区域   |\n| Ctrl + K Ctrl + 0    | Fold (collapse) all regions        | 折叠全部区域   |\n| Ctrl + K Ctrl + J    | Unfold (uncollapse) all regions    | 展开全部区域   |\n| Ctrl + K Ctrl + C    | Add line comment                   | 添加行注释     |\n| Ctrl + K Ctrl + U    | Remove line comment                | 删除行注释     |\n| Ctrl + /             | Toggle line comment                | 行注释         |\n| Shift + Alt + A      | Toggle block comment               | 块注释         |\n| Alt + Z              | Toggle word wrap                   | 切换自动换行   |\n\n<br>\n\n> ### Navigation\n\n| 快捷键             | 描述                            | 中文                |\n| ------------------ | ------------------------------- | ------------------- |\n| Ctrl + T           | Show all Symbols                | 按关键字搜索        |\n| Ctrl + G           | Go to Line...                   | 行跳转              |\n| Ctrl + P           | Go to File...                   | 打开文件            |\n| Ctrl + Shift + O   | Go to Symbol...                 | 转到编辑器中的符号  |\n| Ctrl + Shift + M   | Show Problems panel             | 显示问题面板        |\n| F8                 | Go to next error or warning     | 转到下个错误或警告  |\n| Shift + F8         | Go to previous error or warning | 转到上个错误或警告  |\n| Ctrl + Shift + Tab | Navigate editor group history   | 切换工作区          |\n| Alt + ← / →        | Go back / forward               | 切换工作区          |\n| Ctrl + M           | Toggle Tab moves focus          | 切换 Tab 键移动焦点 |\n\n<br>\n\n> ### Search and replace\n\n| 快捷键            | 描述                                       | 中文                             |\n| ----------------- | ------------------------------------------ | -------------------------------- |\n| Ctrl + F          | Find                                       | 查找                             |\n| Ctrl + H          | Replace                                    | 替换                             |\n| F3 / Shift + F3   | Find next/previous                         | 查找上/下一个                    |\n| Alt + Enter       | Select all occurences of Find match        | 执行笔记本单元格并在下方插入     |\n| Ctrl + D          | Add selection to next Find match           | 将下一个查找匹配项添加到选择     |\n| Ctrl + K Ctrl + D | Move last selection to next Find match     | 将上次选择移动到下一个查找匹配项 |\n| Alt + C / R / W   | Toggle case-sensitive / regex / whole word | 区分大小写/正则匹配/全字匹配     |\n\n<br>\n\n> ### Multi-cursor and selection\n\n| 快捷键                         | 描述                                        | 中文                         |\n| ------------------------------ | ------------------------------------------- | ---------------------------- |\n| Alt + Click                    | Insert cursor                               | 将鼠标点击的行添加到选择项   |\n| Ctrl + Alt + ↑ / ↓             | Insert cursor above / below                 | 在上面/下面插入光标          |\n| Ctrl + U                       | Undo last cursor operation                  | 撤销最后光标操作             |\n| Shift + Alt + I                | Insert cursor at end of each line selected  | 在选定的每一行的末尾插入光标 |\n| Ctrl + L                       | Select current line                         | 选择当前行                   |\n| Ctrl + Shift + L               | Select all occurrences of current selection | 选择当前选择的所有匹配项     |\n| Ctrl + F2                      | Select all occurrences of current word      | 选择当前出现的所有单词       |\n| Shift + Alt + →                | Expand selection                            | 扩大选择                     |\n| Shift + Alt + ←                | Shrink selection                            | 缩小选择                     |\n| Shift + Alt + (drag mouse)     | Column (box) selection                      | 列(箱)的选择                 |\n| Ctrl + Shift+Alt + (arrow key) | Column (box) selection                      | 列(箱)的选择                 |\n| Ctrl + Shift+Alt + PgUp / PgDn | Column (box) selection page up/down         | 列(箱)的选择                 |\n\n<br>\n\n> ### Rich languages editing\n\n| 快捷键             | 描述                        | 中文         |\n| ------------------ | --------------------------- | ------------ |\n| Ctrl + Space       | Trigger suggestion          | 触发的建议   |\n| Ctrl + Shift+Space | Trigger parameter hints     | 触发参数提示 |\n| Shift + Alt + F    | Format document             | 格式化文件   |\n| Ctrl + K Ctrl + F  | Format selection            | 格式选择     |\n| F12                | Go to Definition            | 移至定义区   |\n| Alt + F12          | Peek Definition             |              |\n| Ctrl + K F12       | Open Definition to the side | 打开定义到边 |\n| Ctrl + .           | Quick Fix                   | 快速修复     |\n| Shift + F12        | Show References             | 显示引用     |\n| F2                 | Rename Symbol               | 重命名符号   |\n| Ctrl + K Ctrl + X  | Trim trailing whitespace    | 修剪尾随空格 |\n| Ctrl + K M         | Change file language        | 更改文件语言 |\n\n<br>\n\n> ### Editor management\n\n| 快捷键                     | 描述                                    | 中文                       |\n| -------------------------- | --------------------------------------- | -------------------------- |\n| Ctrl + F4, Ctrl + W        | Close editor                            | 关闭编辑器                 |\n| Ctrl + K F                 | Close folder                            | 关闭文件夹                 |\n| Ctrl + \\                   | Split editor                            | 拆分编辑器                 |\n| Ctrl + 1 / 2 / 3           | Focus into 1st, 2nd or 3rd editor group | 关注第一，第二或第三编辑组 |\n| Ctrl + K Ctrl + ← / →      | Focus into previous/next editor group   | 关注上个/下个编辑组        |\n| Ctrl + Shift + PgUp / PgDn | Move editor left/right                  | 左/右移动编辑器            |\n| Ctrl + K ← / →             | Move active editor group                | 移动活动编辑器组           |\n\n<br>\n\n> ### File management\n\n| 快捷键             | 描述                                    | 中文                        |\n| ------------------ | --------------------------------------- | --------------------------- |\n| Ctrl + N           | New File                                | 创建新文件                  |\n| Ctrl + O           | Open File...                            | 打开文件                    |\n| Ctrl + S           | Save                                    | 保存                        |\n| Ctrl + Shift + S   | Save As...                              | 另保存                      |\n| Ctrl + K S         | Save All                                | 全部保存                    |\n| Ctrl + F4          | Close                                   | 关闭                        |\n| Ctrl + K Ctrl + W  | Close All                               | 关闭全部                    |\n| Ctrl + Shift + T   | Reopen closed editor                    | 重新                        |\n| Ctrl + K           | Enter Keep preview mode editor open     | 重新打开关闭编辑器          |\n| Ctrl + Tab         | Open next                               | 打开下一个                  |\n| Ctrl + Shift + Tab | Open previous                           | 打开上一个                  |\n| Ctrl + K P         | Copy path of active file                | 复制活动文件的路径          |\n| Ctrl + K R         | Reveal active file in Explorer          | 在资源管理器中显示活动文件  |\n| Ctrl + K O         | Show active file in new window/instance | 在新窗口/实例中显示活动文件 |\n\n<br>\n\n> ### Display\n\n| 快捷键           | 描述                                       | 中文                      |\n| ---------------- | ------------------------------------------ | ------------------------- |\n| F11              | Toggle full screen                         | 全屏                      |\n| Shift + Alt + 0  | Toggle editor layout (horizontal/vertical) | 切换编辑器布局(水平/垂直) |\n| Ctrl + = / -     | Zoom in/out                                | 放大/缩小                 |\n| Ctrl + B         | Toggle Sidebar visibility                  | 切换侧栏可见性            |\n| Ctrl + Shift + E | Show Explorer / Toggle focus               | 显示资源管理器            |\n| Ctrl + Shift + F | Show Search                                | 显示搜索栏                |\n| Ctrl + Shift + G | Show Source Control                        | 显示源控制                |\n| Ctrl + Shift + D | Show Debug                                 | 显示 Debug                |\n| Ctrl + Shift + X | Show Extensions                            | 显示插件                  |\n| Ctrl + Shift + H | Replace in files                           | 批量文件替换              |\n| Ctrl + Shift + J | Toggle Search details                      | 切换搜索细节              |\n| Ctrl + Shift + U | Show Output panel                          | 显示输出面板              |\n| Ctrl + Shift + V | Open Markdown preview                      | 打开 Markdown 预览        |\n| Ctrl + K V       | Open Markdown preview to the side          | 侧边打开 Markdown 预览    |\n| Ctrl + K Z       | Zen Mode (Esc Esc to exit)                 |                           |\n\n<br>\n\n> ### Debug\n\n| 快捷键            | 描述              | 中文     |\n| ----------------- | ----------------- | -------- |\n| F9                | Toggle breakpoint | 切换断点 |\n| F5                | Start/Continue    | 开始     |\n| Shift + F5        | Stop              | 停止     |\n| F11 / Shift + F11 | Step into/out     | 步入     |\n| F10               | Step over         | 跨步     |\n| Ctrl+K Ctrl+I     | Show hover        | 显示悬停 |\n\n<br>\n\n> ### Integrated terminal\n\n| 快捷键              | 描述                       | 中文              |\n| ------------------- | -------------------------- | ----------------- |\n| Ctrl + C            | Copy selection             | 复制到活动终端    |\n| Ctrl + V            | Paste into active terminal | 粘贴到活动终端    |\n| Ctrl + ↑ / ↓        | Scroll up/down             | 向上/向下滚动     |\n| Shift + PgUp / PgDn | Scroll page up/down        | 向上/向下滚动页面 |\n| Ctrl + Home / End   | Scroll to top/bottom       | 滚动到顶部/底部   |\n| Ctrl + `            | Show integrated terminal   | 显示终端          |\n| Ctrl + Shift + `    | Create new terminal        | 打开新终端        |\n","tags":["快捷键"]},{"title":"npm常用命令","url":"/2020/10/10/npm-chang-yong-ming-ling/","content":"[npm官方中文文档](https://www.npmjs.cn/getting-started/what-is-npm/)\n\n#### 安装\n\n```js\nnpm i `包名` -g // 全局安装\n\nnpm i `包名` -dev //\n\nnpm i `包名` --save-dev\n```\n\n#### 查看\n\n```js\nnpm -v // 查看安装版本\n\nnpm ls `包名` // 查看该安装包版本\n\nnpm ls `包名` -g // 查看全局安装包版本\n\nnpm view `包名` dependencies // 查看安装包依赖关系\n\nnpm list // 查看已安装包列表\n\n```\n","tags":["npm"]},{"title":"css规范","url":"/2020/10/09/css/css-gui-fan/","content":"转载:https://juejin.im/post/6844903874071887886)\n\n## 1. 通用规范\n<!-- more -->\n### 文件编码\n\n* 为了避免内容乱码，统一使用 UTF-8 编码保存。\n\n* 样式文件第一行设置字符集为 UTF-8\n```css\n@charset 'UTF-8'; /* 注意字符集说明应在第一行 */\n```\n\n### 缩进规范\n\n统一使用两个空格缩进\n\n## 2. 初始化规范\n\n各浏览器厂商的初始样式都不一样，为了消除不同浏览器对 HTML 文本呈现的差异，我们常引入一些初始化样式，如 normalize.css、reset.css 等，当对于这些样式的引入我们需要注意下面几种情况：\n\n\n* 不使用 UI 框架，由零开始搭建\n从零开始搭建的情况下，进行样式初始化，在项目最开始的时候就引入，不要在开发中途引入，避免不可预知的样式冲突。\n\n\n* 不使用 UI 框架，但使用了部分插件\n插件往往都带有自己特有的样式，如富文本插件，在开发中途使用初始化样式有可能导致样式错乱，所以不建议大范围的初始化，只需简单进行初始化即可。\n```css\n* {\n  padding: 0;\n  margin: 0;\n}\n```\n\n* 已使用 UI 框架\n在明确知道需要使用 UI 框架的时候，不使用第三方初始化样式，不管是在项目开始前还是进行中，因为 UI 框架一般都自带初始化，额外引入了反而会影响原有效果。\n\n## 3. 代码规范\n\n### 命名规范\n\n> class 应以功能或内容命名，不以表现形式命名\nclass 与 id 单词字母小写，多个单词组成时，采用中划线-分隔\n使用唯一的 id 作为 Javascript hook, 同时避免创建无样式信息的 class\n\n### 代码风格\n\n* 统一使用展开格式，不推荐紧凑格式\n* 统一两个空格缩进\n* 属性声明结尾加分号\n* 选择器与左括号之间一个空格，属性冒号后一个空格\n* 不要为 0 指明单位\n* 颜色值和属性值十六进制数值能用简写的尽量用简写\n```css\n/* 推荐 */\n.test {\n  color: #fff;\n}\n\n/* 不推荐 */\n.test {\n  color: #ffffff;\n}\n```\n* 引号使用\n\nurl() 、属性选择符、属性值使用单引号\n\n* 清除浮动\n\n当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。\n触发 BFC 的方式很多，常见的有：\n> * float 非 none\n> * position 非 static\n> * overflow 非 visible\n\n### 字体规范\n\n* 对外商用网站，不要用font-face引入微软雅黑字体，避免侵权（包括图片内容）\n* 需要在 Windows 平台显示的中文内容，其字号应不小于 12px\n> 网站上使用 微软雅黑 字体有三种形式：\n>\n> 1、【侵权】图片中使用 微软雅黑 字体，比如网站头图<br>\n> 2、【安全】网站 CSS 用 font-family 声明网站使用 微软雅黑 字体，比如文章标题和正文<br>\n> 3、【侵权】网站通过 font-face 引用 微软雅黑 ，这种方式不常见\n\n### 选择器规范\n\n在严格遵照BEM([Block Element Modifier](http://getbem.com/))时，建议只使用类选择器，但 BEM 书写麻烦，所以建议如下\n\n* 禁用通用选择器 *\n* 不使用无具体语义定义的标签选择器\n\n### 属性顺序\n\nCSS 属性顺序是 CSS 良好编码风格的一部分，有助于提高代码可读性，便于发现代码问题，有利于团队合作，但在项目中发现部分同学在书写属性顺序时较为随意，想到一个属性就写一个。\n\n建议使用下列顺序进行书写\n1. 定位属性（position、display、float、left、right）\n2. 尺寸属性（width、height、padding、margin、border）\n3. 字体属性（color、font、text-align）\n4. 其他属性（background、cursor、outline）\n\n目的是在浏览代码时，能逐步清晰目标元素的效果。\n```\n.test {\n  display: block;\n  position: relative;\n  float: left;\n  width: 100px;\n  height: 100px;\n  margin: 0 10px;\n  padding: 20px 0;\n  font-size: 12px;\n  color: #333;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 10px;\n}\n```\n\n## 4. 注释规范\n\n### 单行注释\n注释以 /* 开始，以 */ 结束,注释内不能嵌套注释，注释内容前后空一个空格。\n\n> 注：在 sass 和 less 等预处理语言上也可以使用双斜线注释，但编译后注释内容不会出现在 css 文件中，所以建议统一使用/* */注释。\n### 模块注释\n有时候我们需要对一个模块(一段代码块)进行功能性说明，并希望能明显区分其它代码，我们可以模块注释的方式。\n\n注释以 /* 开始，以 */ 结束，前后空一个空格，第一行填写描述，最后一行行填写分割线。\n```\n/* 推荐的模块注释\n---------------------------------------------------- */\n```\n\n### 文件信息注释\n如果需要对一个文件进行功能性说明，方便其他人快速明白该文件的作用，推荐在文件开头(字符集说明下)写入下列注释，注释内容包括文件描述、创建人、创建时间等。\n```\n@charset \"UTF-8\";\n/**\n * @desc 文件功能描述，方便其他人快速理解\n * @author 创建人\n * @date 创建时间\n */\n```\n\n## 5. 覆盖规范\n\n* 尽可能少用 importent\n* vue 单文件组件统一使用 css/less/sass scoped\n* 每个页面/组件需要有一个全局唯一的标识 id/class，属于它下面的样式都需要加上该唯一标识\n* 避免全局修改已有样式，必须具体到页面上(通过权重)\n* 禁用全匹配*选择器（特殊情况除外，如初始化）\n> vue 单文件组件修改样式不生效可使用 /deep/ 或 >>>\n\n## 6. 媒体查询\n\n对于内部管理系统，商务多使用 ThinkPad 笔记本，屏幕分辨率为 1366*768。建议使用Resolution Test浏览器拓展进行浏览器窗口大小调试。\n\n下载地址：www.cnplugins.com/devtool/res…\n\n常用尺寸如下\n|  表头   | 描述  |\n|  ----  | ----  |\n| ≥1366px  | 大屏幕 大桌面显示器 |\n| ≥1200px  | 中等屏幕 桌面显示器 |\n| ≥992px  | 中等屏幕 桌面显示器 |\n| ≥768px  | 小屏幕 平板 |\n| <768px  | 超小屏幕 手机 |\n\n### 优先 PC 端\n\n默认按最大尺寸进行布局，当尺寸缩小时逐步变成移动端布局\n```css\nbody {\n  background: gray;\n}\n@media screen and (max-width: 1366px) {\n  body {\n    background: red;\n  }\n}\n@media screen and (max-width: 1200px) {\n  body {\n    background: yellow;\n  }\n}\n@media screen and (max-width: 920px) {\n  body {\n    background: green;\n  }\n}\n@media screen and (max-width: 768px) {\n  body {\n    background: black;\n  }\n}\n\n```\n### 优先移动端\n\n默认按最小尺寸进行布局，当尺寸放大时逐步变成 PC 端布局\n```css\nbody {\n  background: gray;\n}\n@media (min-width: 768px) {\n  body {\n    background: red;\n  }\n}\n@media (min-width: 920px) {\n  body {\n    background: green;\n  }\n}\n@media (min-width: 1200px) {\n  body {\n    background: yellow;\n  }\n}\n@media (min-width: 1366px) {\n  body {\n    background: red;\n  }\n}\n```\n如果需要做打印样式进行适配，需要使用@media print\n```css\n@media print {\n  body {\n    background: #fff;\n  }\n}\n```\n## 7. 单位规范\nCSS 单位有两种，分别是绝对单位和相对单位。\n\n\n* 常用绝对单位\n  - px：像素 (计算机屏幕上的一个点)\n  - cm：厘米\n  - in：英寸\n  - pt：磅 (1 pt 等于 1/72 英寸)\n\n\n\n* 常用相对单位\n  - %：父元素百分比\n  - vw：视口宽度百分比\n  - vh：视口高度百分比\n  - em：当前字体倍数\n  - rem：根元素字体倍数\n> rpx：微信小程序专用，规定屏幕宽为 750rpx\n\n\n\n使用较多的单位有 px、%、rem 三种，建议 PC 端用 px 单位、移动端用 rem，需要具体控制尺寸还是使用 px\n备注：如果需要计算不同单位下的值，可以使用 css3 方法 calc()\n\n## 8. 兼容性规范\n\n### 私有属性的使用\n\n正是由于浏览器厂商的不同，导致了一些样式需要加前缀才生效，下面的常见的浏览器内核和前缀\n|  浏览器   | 内核  | 前缀 |\n|  ----  | ----  | ----  |\n| Firefox  | Gecko | -moz- |\n| Chrome  | WebKit | -webkit- |\n| IE | Trident | -ms- |\n| Safari  | WebKit | -webkit- |\n| Opera  | Presto | -o- |\n| 国内知名浏览器  | WebKit | -webkit- |\n| 常见手机浏览器  | WebKit | -webkit- |\n\nCSS3 浏览器私有前缀在前，标准前缀在后\n```css\n.test {\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -o-border-radius: 10px;\n  -ms-border-radius: 10px;\n  border-radius: 10px;\n}\n```\n> 备注：在 webpack 环境下，可以使用 postcss-loader 自动添加私有前缀","tags":["css"]},{"title":"正则表达式","url":"/2020/10/09/javascript/zheng-ze-biao-da-shi/","content":"### [常用正则](https://juejin.im/post/6844904182835757064)","tags":["正则表达式"]},{"title":"Airbnb JavaScript 风格指南阅读笔记","url":"/2020/10/09/javascript/airbnb-javascript-feng-ge-zhi-nan/","content":"\n### Types\n<!-- more -->\n\n#### 1.1 基本类型: 你可以直接获取到基本类型的值\n\n- `string`\n- `number`\n- `boolean`\n- `null`\n- `undefined`\n- `symbol`\n\n```javascript\nconst foo = 1\nlet bar = foo\n\nbar = 9\n\nconsole.log(foo, bar) // => 1,9\n```\n\n#### 1.2 复杂类型: 复杂类型赋值是获取到他的引用的值。 相当于传引用\n\n- `object`\n- `array`\n- `function`\n\n```javascript\nconst foo = [1, 2]\nconst bar = foo\n\nbar[0] = 9\n\nconsole.log(foo[0], bar[0]) // => 9, 9\n```\n\n#### 1.3 javascript 判断数据类型方法\n\n- typeof\n\n```javascript\ntypeof '' // => string\ntypeof 1 // => number\ntypeof true // => boolean\ntypeof Symbol() // => symbol\ntypeof undefined // => undefined\ntypeof null // => object\ntypeof new Function() // => function\ntypeof new Date() // => object\ntypeof [] // => object\ntypeof new RegExp() // => object\ntypeof new Error() // => object\ntypeof document // => object\ntypeof window // => object\n```\n\n引用类型，除了 function 返回 function 类型外，其他都返回 object。但引用类型中的数组、日期、正则都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型。\n\n- toString\n\n```javascript\nObject.prototype.toString.call('') // =>[object String]\nObject.prototype.toString.call(1) // => [object Number]\nObject.prototype.toString.call(true) // => [object Boolean]\nObject.prototype.toString.call(Symbol()) // =>[object Symbol]\nObject.prototype.toString.call(undefined) // => [object Undefined]\nObject.prototype.toString.call(null) // => [object Null]\nObject.prototype.toString.call(new Function()) // => [object Function]\nObject.prototype.toString.call(new Date()) // => [object Date]\nObject.prototype.toString.call([]) // => [object Array]\nObject.prototype.toString.call(new RegExp()) // => [object RegExp]\nObject.prototype.toString.call(new Error()) // => [object Error]\nObject.prototype.toString.call(document) // => [object HTMLDocument]\nObject.prototype.toString.call(window) // =>[object global] window 是全局对象 global 的引用\n```\n\ntoString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。\n\n对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。\n\n- constructor\n\n```javascript\n''.constructor == String // => true\nnew Number(1).constructor == Number // => true\ntrue.constructor == Boolean // => true\nnew Function().constructor == Function // => true\nnew Date().constructor == Date // => true\nnew Error().constructor == Error // => true\n[].constructor == Array // => true\ndocument.constructor == HTMLDocument // => true\nwindow.constructor == Window // => true\n```\n\nconstructor 是原型 prototype 的一个属性，当函数被定义时候，js 引擎会为函数添加原型 prototype，并且这个 prototype 中 constructor 属性指向函数引用， 因此重写 prototype 会丢失原来的 constructor。\n缺点：\n\n1. null 和 undefined 无 constructor，这种方法判断不了\n\n2. 还有，如果自定义对象，开发者重写 prototype 之后，原有的 constructor 会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改\n\n- instanceof\n\n  instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型\n\n![](0.png)\n\n由上图可以看出[]的原型指向 Array.prototype，间接指向 Object.prototype, 因此 [] instanceof Array 返回 true， [] instanceof Object 也返回 true。\n\ninstanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型\n\n### References\n\n#### 2.1 所有的赋值都用 const，避免使用`var`. eslint: `prefer-const`, `no-const-assign`\n\n> Why? 因为这个确保你不会改变你的初始值，重复引用会导致 bug 和代码难以理解\n\n```javascript\n// bad\nvar a = 1\nvar b = 2\n\n// good\nconst a = 1\nconst b = 2\n```\n\n#### 2.2 如果你一定要对参数重新赋值，那就用`let`，而不是`var`. eslint: `no-var`\n\n> Why? 因为 let 是块级作用域，而 var 是函数级作用域\n\n```javascript\n// bad\nvar count = 1\nif (true) {\n  count += 1\n}\n\n// good, use the let.\nlet count = 1\nif (true) {\n  count += 1\n}\n```\n\n#### 2.3 注意： `let`、`const` 都是块级作用域\n\n```javascript\n// const 和 let 都只存在于它定义的那个块级作用域\n{\n  let a = 1\n  const b = 1\n}\nconsole.log(a) // ReferenceError\nconsole.log(b) // ReferenceError\n```\n\n### Objects\n\n#### 3.1 使用字面值创建对象. eslint: `no-new-object`\n\n```javascript\n// bad\nconst item = new Object()\n\n// good\nconst item = {}\n```\n\n#### 3.2 当创建一个带有动态属性名的对象时，用计算后属性名\n\n> Why? 这可以使你将定义的所有属性放在对象的一个地方.\n\n```javascript\nfunction getKey(k) {\n  return `a key named ${k}`\n}\n\n// bad\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n}\nobj[getKey('enabled')] = true\n\n// good getKey('enabled')是动态属性名\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n  [getKey('enabled')]: true,\n}\n```\n\n#### 3.3 用对象方法简写. eslint: `object-shorthand`\n\n```javascript\n// bad\nconst atom = {\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value\n  },\n}\n\n// good\nconst atom = {\n  value: 1,\n\n  // 对象的方法\n  addValue(value) {\n    return atom.value + value\n  },\n}\n```\n\n#### 3.4 用属性值缩写. eslint: `object-shorthand`\n\n```javascript\nconst lukeSkywalker = 'Luke Skywalker'\n\n// bad\nconst obj = {\n  lukeSkywalker: lukeSkywalker,\n}\n\n// good\nconst obj = {\n  lukeSkywalker,\n}\n```\n\n#### 3.5 将你的所有缩写放在对象声明的开始.\n\n> Why? 这样也是为了更方便的知道有哪些属性用了缩写.\n\n```javascript\nconst anakinSkywalker = 'Anakin Skywalker'\nconst lukeSkywalker = 'Luke Skywalker'\n\n// bad\nconst obj = {\n  episodeOne: 1,\n  twoJediWalkIntoACantina: 2,\n  lukeSkywalker,\n  episodeThree: 3,\n  mayTheFourth: 4,\n  anakinSkywalker,\n}\n\n// good\nconst obj = {\n  lukeSkywalker,\n  anakinSkywalker,\n  episodeOne: 1,\n  twoJediWalkIntoACantina: 2,\n  episodeThree: 3,\n  mayTheFourth: 4,\n}\n```\n\n#### 3.6 只对那些无效的标示使用引号 ''. eslint: `quote-props`\n\n> Why? 通常我们认为这种方式主观上易读。他优化了代码高亮，并且页更容易被许多 JS 引擎压缩。\n\n```javascript\n// bad\nconst bad = {\n  'foo': 3,\n  'bar': 4,\n  'data-blah': 5,\n}\n\n// good\nconst good = {\n  foo: 3,\n  bar: 4,\n  'data-blah': 5,\n}\n```\n\n#### 3.7 不要直接调用`Object.prototype`上的方法，如`hasOwnProperty`, `propertyIsEnumerable`, `isPrototypeOf`。\n> Why? 在一些有问题的对象上， 这些方法可能会被屏蔽掉 - 如：{ hasOwnProperty: false } - 或这是一个空对象Object.create(null)\n\n```javascript\n// bad\nconsole.log(object.hasOwnProperty(key));\n\n// good\nconsole.log(Object.prototype.hasOwnProperty.call(object, key));\n\n// best\nconst has = Object.prototype.hasOwnProperty; // 在模块作用内做一次缓存\n/* or */\nimport has from 'has'; // https://www.npmjs.com/package/has\n// ...\nconsole.log(has.call(object, key));\n```\n\n#### 3.8 对象浅拷贝时，更推荐使用扩展运算符`[就是...运算符]`，而不是`Object.assign`。获取对象指定的几个属性时，用对象的rest解构运算符`[也是...运算符]`更好。\n\n```javascript\n// very bad\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ\ndelete copy.a; // so does this\n\n// bad\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }\n\n// good es6扩展运算符 ...\nconst original = { a: 1, b: 2 };\n// 浅拷贝\nconst copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }\n\n// rest 赋值运算符\nconst { a, ...noA } = copy; // noA => { b: 2, c: 3 }\n```\n\n### Arrays\n\n#### 4.1 用字面量赋值。 eslint: `no-array-constructor`\n\n```javascript\n// bad\nconst items = new Array();\n\n// good\nconst items = [];\n```\n\n#### 4.2 用`Array#push` 代替直接向数组中添加一个值。\n\n```javascript\nconst someStack = [];\n\n// bad\nsomeStack[someStack.length] = 'abracadabra';\n\n// good\nsomeStack.push('abracadabra');\n```\n\n#### 4.3 用扩展运算符做数组浅拷贝，类似上面的对象浅拷贝\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n#### 4.4 用 `...` 运算符而不是Array.from来将一个可迭代的对象转换成数组。\n\n```javascript\nconst foo = document.querySelectorAll('.foo');\n\n// good\nconst nodes = Array.from(foo);\n\n// best\nconst nodes = [...foo];\n```\n\n#### 4.5 用 `Array.from` 去将一个类数组对象转成一个数组。\n\n```javascript\nconst arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };\n\n// bad\nconst arr = Array.prototype.slice.call(arrLike);\n\n// good\nconst arr = Array.from(arrLike);\n```\n\n#### 4.6 用 `Array.from` 而不是 `...` 运算符去做map遍历。 因为这样可以避免创建一个临时数组。\n\n```javascript\n// bad\nconst baz = [...foo].map(bar);\n\n// good\nconst baz = Array.from(foo, bar);\n```\n\n#### 4.7 在数组方法的回调函数中使用 `return` 语句。 如果函数体由一条返回一个表达式的语句组成， 并且这个表达式没有副作用， 这个时候可以忽略`return`，详见 8.2. eslint: `array-callback-return`。\n\n```javascript\n// good\n[1, 2, 3].map((x) => {\n  const y = x + 1;\n  return x * y;\n});\n\n// good 函数只有一个语句\n[1, 2, 3].map(x => x + 1);\n\n// bad - 没有返回值， 因为在第一次迭代后acc 就变成undefined了\n[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) => {\n  const flatten = acc.concat(item);\n  acc[index] = flatten;\n});\n\n// good\n// reduce没有设置初始值，则默认取数组第一个值为初始值\n[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) => {\n  const flatten = acc.concat(item);\n  acc[index] = flatten;\n  return flatten;\n});\n\n// bad\ninbox.filter((msg) => {\n  const { subject, author } = msg;\n  if (subject === 'Mockingbird') {\n    return author === 'Harper Lee';\n  } else {\n    return false;\n  }\n});\n\n// good\ninbox.filter((msg) => {\n  const { subject, author } = msg;\n  if (subject === 'Mockingbird') {\n    return author === 'Harper Lee';\n  }\n\n  return false;\n});\n```\n\n#### 4.8 如果一个数组有很多行，在数组的 [ 后和 ] 前断行。 请看下面示例\n\n```javascript\n// bad\nconst arr = [\n  [0, 1], [2, 3], [4, 5],\n];\n\nconst objectInArray = [{\n  id: 1,\n}, {\n  id: 2,\n}];\n\nconst numberInArray = [\n  1, 2,\n];\n\n// good\nconst arr = [[0, 1], [2, 3], [4, 5]];\n\nconst objectInArray = [\n  {\n    id: 1,\n  },\n  {\n    id: 2,\n  },\n];\n\nconst numberInArray = [\n  1,\n  2,\n];\n```\n\n### Destructuring\n\n#### 5.1 用对象的解构赋值来获取和使用对象某个或多个属性值。 eslint: `prefer-destructuring`\n> Why? 解构使您不必为这些属性创建临时引用\n\n```javascript\n// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n\n  return `${firstName} ${lastName}`;\n}\n\n// good\nfunction getFullName(user) {\n  const { firstName, lastName } = user;\n  return `${firstName} ${lastName}`;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\n```\n\n#### 5.2 用数组解构。\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n```\n\n#### 5.3 多个返回值用对象的解构，而不是数组解构。\n> Why? 你可以在后期添加新的属性或者变换变量的顺序而不会打破原有的调用\n\n```javascript\n// bad\nfunction processInput(input) {\n  // 然后就是见证奇迹的时刻\n  return [left, right, top, bottom];\n}\n\n// 调用者需要想一想返回值的顺序\nconst [left, __, top] = processInput(input);\n\n// good\nfunction processInput(input) {\n  // oops， 奇迹又发生了\n  return { left, right, top, bottom };\n}\n\n// 调用者只需要选择他想用的值就好了\nconst { left, top } = processInput(input);\n```\n\n### Strings\n\n#### 6.1 对`string`用单引号 '' 。 eslint: `quotes`\n\n```javascript\n// bad\nconst name = \"Capt. Janeway\";\n\n// bad - 样例应该包含插入文字或换行\nconst name = `Capt. Janeway`;\n\n// good\nconst name = 'Capt. Janeway';\n```\n\n#### 6.2 超过100个字符的字符串不应该用`string`串联成多行。\n> Why? 被折断的字符串工作起来是糟糕的而且使得代码更不易被搜索。\n\n```javascript\n// bad\nconst errorMessage = 'This is a super long error that was thrown because \\\nof Batman. When you stop to think about how Batman had anything to do \\\nwith this, you would get nowhere \\\nfast.';\n\n// bad\nconst errorMessage = 'This is a super long error that was thrown because ' +\n  'of Batman. When you stop to think about how Batman had anything to do ' +\n  'with this, you would get nowhere fast.';\n\n// good\nconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';\n```\n\n#### 6.3 用字符串模板而不是字符串拼接来组织可编程字符串。 eslint: `prefer-template` `template-curly-spacing`\n> Why? 模板字符串更具可读性、语法简洁、字符串插入参数。\n\n```javascript\n// bad\nfunction sayHi(name) {\n  return 'How are you, ' + name + '?';\n}\n\n// bad\nfunction sayHi(name) {\n  return ['How are you, ', name, '?'].join();\n}\n\n// bad\nfunction sayHi(name) {\n  return `How are you, ${ name }?`;\n}\n\n// good\nfunction sayHi(name) {\n  return `How are you, ${name}?`;\n}\n```\n\n#### 6.4 永远不要在字符串中用`eval()`，他就是潘多拉盒子。 eslint: `no-eval`\n\n#### 6.5 不要使用不必要的转义字符。eslint: `no-useless-escape`\n> Why? 反斜线可读性差，所以他们只在必须使用时才出现哦\n\n```javascript\n// bad\nconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';\n\n// good\nconst foo = '\\'this\\' is \"quoted\"';\n\n//best\nconst foo = `my name is '${name}'`;\n```\n\n### Functions\n\n#### 7.1 用命名函数表达式而不是函数声明。eslint: `func-style`\n> 函数表达式： const func = function () {}\n\n> 函数声明： function func() {}\n\n> Why? 函数声明时作用域被提前了，这意味着在一个文件里函数很容易（太容易了）在其定义之前被引用。这样伤害了代码可读性和可维护性。如果你发现一个函数又大又复杂，这个函数妨碍这个文件其他部分的理解性，这可能就是时候把这个函数单独抽成一个模块了。别忘了给表达式显示的命名，不用管这个名字是不是由一个确定的变量推断出来的，这消除了由匿名函数在错误调用栈产生的所有假设，这在现代浏览器和类似babel编译器中很常见 (Discussion)\n\n```javascript\n// bad\nfunction foo() {\n  // ...\n}\n\n// bad\nconst foo = function () {\n  // ...\n};\n\n// good\n// lexical name distinguished from the variable-referenced invocation(s)\n// 函数表达式名和声明的函数名是不一样的\nconst short = function longUniqueMoreDescriptiveLexicalFoo() {\n  // ...\n};\n```\n\n#### 7.2 把立即执行函数包裹在圆括号里。 eslint: `wrap-iife`\n\n> Why? immediately invoked function expression = IIFE Why? 一个立即调用的函数表达式是一个单元 - 把它和他的调用者（圆括号）包裹起来，在括号中可以清晰的地表达这些。 Why? 注意：在模块化世界里，你几乎用不着 IIFE\n\n```javascript\n// immediately-invoked function expression (IIFE)\n(function () {\n  console.log('Welcome to the Internet. Please follow me.');\n}());\n```\n\n#### 7.2.1 IIFE\n\nIIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，也就是说，声明函数的同时立即调用这个函数。\n\n* 不采用IIFE时的函数声明和函数调用：\n\n``` javascript\nfunction foo(){\n  var a = 10;\n  console.log(a);\n}\nfoo();\n```\n\n* IIFE形式的函数调用：\n\n``` javascript\n(function foo(){\n  var a = 10;\n  console.log(a);\n})();\n```\n\n函数的声明和IIFE的区别在于，在函数的声明中，我们首先看到的是function关键字，而IIFE我们首先看到的是左边的（。也就是说，使用一对（）将函数的声明括起来，使得JS编译器不再认为这是一个函数声明，而是一个IIFE，即需要立刻执行声明的函数。\n两者达到的目的是相同的，都是声明了一个函数foo并且随后调用函数foo。\n\n#### 7.3 不要在非函数块（`if`、`while`等等）内声明函数。把这个函数分配给一个变量。浏览器会允许你这样做，但浏览器解析方式不同，这是一个坏消息。【详见no-loop-func】 eslint: `no-loop-func`\n\n#### 7.4 Note: 在ECMA-262中 [块 `block`] 的定义是： 一系列的语句； 但是函数声明不是一个语句。 函数表达式是一个语句。\n\n```javascript\n// bad\nif (currentUser) {\n  function test() {\n    console.log('Nope.');\n  }\n}\n\n// good\nlet test;\nif (currentUser) {\n  test = () => {\n    console.log('Yup.');\n  };\n}\n```\n\n#### 7.5 不要用`arguments`命名参数。他的优先级高于每个函数作用域自带的`arguments`对象， 这会导致函数自带的`arguments`值被覆盖\n\n```javascript\n// bad\nfunction foo(name, options, arguments) {\n  // ...\n}\n\n// good\nfunction foo(name, options, args) {\n  // ...\n}\n```\n\n#### 7.6 不要使用`arguments`，用rest语法`...`代替。 eslint: `prefer-rest-params`\n\n> Why? ...明确你想用那个参数。而且rest参数是真数组，而不是类似数组的arguments\n\n```javascript\n// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n```\n\n#### 7.7 用默认参数语法而不是在函数里对参数重新赋值。\n\n```javascript\n// really bad\nfunction handleThings(opts) {\n  // 不， 我们不该改arguments\n  // 第二： 如果 opts 的值为 false, 它会被赋值为 {}\n  // 虽然你想这么写， 但是这个会带来一些细微的bug\n  opts = opts || {};\n  // ...\n}\n\n// still bad\nfunction handleThings(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // ...\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n```\n\n#### 7.8 默认参数避免副作用\n\n> Why? 他会令人迷惑不解， 比如下面这个， a到底等于几， 这个需要想一下。\n\n```javascript\nvar b = 1;\n// bad\nfunction count(a = b++) {\n  console.log(a);\n}\ncount();  // 1\ncount();  // 2\ncount(3); // 3\ncount();  // 3\n```\n\n#### 7.9 把默认参数赋值放在最后\n\n```javascript\n// bad\nfunction handleThings(opts = {}, name) {\n  // ...\n}\n\n// good\nfunction handleThings(name, opts = {}) {\n  // ...\n}\n```\n\n#### 7.10 不要用函数构造器创建函数。 eslint: `no-new-func`\n\n> Why? 以这种方式创建函数将类似于字符串 eval()，这会打开漏洞。\n\n```javascript\n// bad\nvar add = new Function('a', 'b', 'return a + b');\n\n// still bad\nvar subtract = Function('a', 'b', 'return a - b');\n```\n\n#### 7.11 函数签名部分要有空格。eslint: `space-before-function-paren` `space-before-blocks`\n\n> Why? 统一性好，而且在你添加/删除一个名字的时候不需要添加/删除空格\n\n```javascript\n// bad\nconst f = function(){};\nconst g = function (){};\nconst h = function() {};\n\n// good\nconst x = function () {};\nconst y = function a() {};\n```\n\n#### 7.12 不要改参数. eslint: `no-param-reassign`\n\n> Why? 操作参数对象对原始调用者会导致意想不到的副作用。 就是不要改参数的数据结构，保留参数原始值和数据结构。\n\n```javascript\n// bad\nfunction f1(obj) {\n  obj.key = 1;\n};\n\n// good\nfunction f2(obj) {\n  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;\n};\n```\n\n#### 7.13 不要对参数重新赋值。 eslint: `no-param-reassign`\n\n> Why? 参数重新赋值会导致意外行为，尤其是对 arguments。这也会导致优化问题，特别是在V8里\n\n```javascript\n// bad\nfunction f1(a) {\n  a = 1;\n  // ...\n}\n\nfunction f2(a) {\n  if (!a) { a = 1; }\n  // ...\n}\n\n// good\nfunction f3(a) {\n  const b = a || 1;\n  // ...\n}\n\nfunction f4(a = 1) {\n  // ...\n}\n```\n\n#### 7.14 用spread操作符...去调用多变的函数更好。 eslint: `prefer-spread`\n\n> Why? 这样更清晰，你不必提供上下文，而且你不能轻易地用apply来组成new\n\n```javascript\n// bad\nconst x = [1, 2, 3, 4, 5];\nconsole.log.apply(console, x);\n\n// good\nconst x = [1, 2, 3, 4, 5];\nconsole.log(...x);\n\n// bad\nnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));\n\n// good\nnew Date(...[2016, 8, 5]);\n```\n\n#### 7.15 调用或者书写一个包含多个参数的函数应该像这个指南里的其他多行代码写法一样： 每行值包含一个参数，每行逗号结尾。\n\n```javascript\n// bad\nfunction foo(bar,\n             baz,\n             quux) {\n  // ...\n}\n\n// good 缩进不要太过分\nfunction foo(\n  bar,\n  baz,\n  quux,\n) {\n  // ...\n}\n\n// bad\nconsole.log(foo,\n  bar,\n  baz);\n\n// good\nconsole.log(\n  foo,\n  bar,\n  baz,\n);\n```\n\n### Arrow Functions\n\n#### 8.1 当你一定要用函数表达式（在回调函数里）的时候就用箭头表达式吧。 eslint: `prefer-arrow-callback`, `arrow-spacing`\n\n> Why? 他创建了一个this的当前执行上下文的函数的版本，这通常就是你想要的；而且箭头函数是更简洁的语法\n\n> Why? 什么时候不用箭头函数： 如果你有一个相当复杂的函数，你可能会把这个逻辑移出到他自己的函数声明里。\n\n```javascript\n// bad\n[1, 2, 3].map(function (x) {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  const y = x + 1;\n  return x * y;\n});\n```\n\n#### 8.2 如果函数体由一个没有副作用的表达式语句组成，删除大括号和`return`。否则，继续用大括号和 `return` 语句。 eslint: `arrow-parens`, `arrow-body-style`\n\n> Why? 语法糖，当多个函数链在一起的时候好读\n\n```javascript\n// bad\n[1, 2, 3].map(number => {\n  const nextNumber = number + 1;\n  `A string containing the ${nextNumber}.`;\n});\n\n// good\n[1, 2, 3].map(number => `A string containing the ${number}.`);\n\n// good\n[1, 2, 3].map((number) => {\n  const nextNumber = number + 1;\n  return `A string containing the ${nextNumber}.`;\n});\n\n// good\n[1, 2, 3].map((number, index) => ({\n  [index]: number\n}));\n\n// 表达式有副作用就不要用隐式return\nfunction foo(callback) {\n  const val = callback();\n  if (val === true) {\n    // Do something if callback returns true\n  }\n}\n\nlet bool = false;\n\n// bad\n// 这种情况会return bool = true, 不好\nfoo(() => bool = true);\n\n// good\nfoo(() => {\n  bool = true;\n});\n```\n\n#### 8.3 万一表达式涉及多行，把他包裹在圆括号里更可读。\n\n> Why? 这样清晰的显示函数的开始和结束\n\n```javascript\n// bad\n['get', 'post', 'put'].map(httpMethod => Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod\n  )\n);\n\n// good\n['get', 'post', 'put'].map(httpMethod => (\n  Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod\n  )\n));\n```\n\n#### 8.4 如果你的函数只有一个参数并且函数体没有大括号，就删除圆括号。否则，参数总是放在圆括号里。 注意： 一直用圆括号也是没问题，只需要配置 “always” option for eslint. eslint: `arrow-parens`\n\n> Why? 这样少一些混乱， 其实没啥语法上的讲究，就保持一个风格。\n\n```javascript\n// bad\n[1, 2, 3].map((x) => x * x);\n\n// good\n[1, 2, 3].map(x => x * x);\n\n// good\n[1, 2, 3].map(number => (\n  `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`\n));\n\n// bad\n[1, 2, 3].map(x => {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  const y = x + 1;\n  return x * y;\n});\n```\n\n#### 8.5 避免箭头函数(`=>`)和比较操作符（`<=`, `>=`）混淆. eslint: `no-confusing-arrow`\n\n```javascript\n// bad\nconst itemHeight = (item) => item.height <= 256 ? item.largeSize : item.smallSize;\n\n// bad\nconst itemHeight = (item) => item.height >= 256 ? item.largeSize : item.smallSize;\n\n// good\nconst itemHeight = (item) => (item.height <= 256 ? item.largeSize : item.smallSize);\n\n// good\nconst itemHeight = (item) => {\n  const { height, largeSize, smallSize } = item;\n  return height <= 256 ? largeSize : smallSize;\n};\n```\n\n#### 8.6 在隐式`return`中强制约束函数体的位置， 就写在箭头后面。 eslint: `implicit-arrow-linebreak`\n\n```javascript\n// bad\n(foo) =>\n  bar;\n\n(foo) =>\n  (bar);\n\n// good\n(foo) => bar;\n(foo) => (bar);\n(foo) => (\n   bar\n)\n```\n\n### Classes & Constructors\n\n#### 9.1 常用class，避免直接操作prototype\n\n> Why? class语法更简洁更易理解\n\n```javascript\n// bad\nfunction Queue(contents = []) {\n  this.queue = [...contents];\n}\nQueue.prototype.pop = function () {\n  const value = this.queue[0];\n  this.queue.splice(0, 1);\n  return value;\n};\n\n\n// good\nclass Queue {\n  constructor(contents = []) {\n    this.queue = [...contents];\n  }\n  pop() {\n    const value = this.queue[0];\n    this.queue.splice(0, 1);\n    return value;\n  }\n}\n```\n\n#### 9.2 用extends实现继承\n\n> Why? 它是一种内置的方法来继承原型功能而不打破instanceof\n\n```javascript\n// bad\nconst inherits = require('inherits');\nfunction PeekableQueue(contents) {\n  Queue.apply(this, contents);\n}\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function () {\n  return this.queue[0];\n}\n\n// good\nclass PeekableQueue extends Queue {\n  peek() {\n    return this.queue[0];\n  }\n}\n```\n\n#### 9.3 方法可以返回this来实现方法链\n\n```javascript\n// bad\nJedi.prototype.jump = function () {\n  this.jumping = true;\n  return true;\n};\n\nJedi.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nconst luke = new Jedi();\nluke.jump(); // => true\nluke.setHeight(20); // => undefined\n\n// good\nclass Jedi {\n  jump() {\n    this.jumping = true;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\n\nconst luke = new Jedi();\n\nluke.jump()\n  .setHeight(20);\n```\n\n#### 9.4 写一个定制的`toString()`方法是可以的，只要保证它是可以正常工作且没有副作用的\n\n```javascript\nclass Jedi {\n  constructor(options = {}) {\n    this.name = options.name || 'no name';\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  toString() {\n    return `Jedi - ${this.getName()}`;\n  }\n}\n```\n\n#### 9.5 如果没有具体说明，类有默认的构造方法。一个空的构造函数或只是代表父类的构造函数是不需要写的。 eslint: `no-useless-constructor`\n\n```javascript\n// bad\nclass Jedi {\n  constructor() {}\n\n  getName() {\n    return this.name;\n  }\n}\n\n// bad\nclass Rey extends Jedi {\n  // 这种构造函数是不需要写的\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n// good\nclass Rey extends Jedi {\n  constructor(...args) {\n    super(...args);\n    this.name = 'Rey';\n  }\n}\n```\n\n#### 9.6 避免重复类成员。 eslint: `no-dupe-class-members`\n\n> Why? 重复类成员会默默的执行最后一个 —— 重复本身也是一个bug\n\n```javascript\n// bad\nclass Foo {\n  bar() { return 1; }\n  bar() { return 2; }\n}\n\n// good\nclass Foo {\n  bar() { return 1; }\n}\n\n// good\nclass Foo {\n  bar() { return 2; }\n}\n```\n\n#### 9.7 除非外部库或框架需要使用特定的非静态方法，否则类方法应该使用this或被做成静态方法。 作为一个实例方法应该表明它根据接收者的属性有不同的行为。eslint: `class-methods-use-this`\n\n```javascript\n// bad\nclass Foo {\n  bar() {\n    console.log('bar');\n  }\n}\n\n// good - this 被使用了\nclass Foo {\n  bar() {\n    console.log(this.bar);\n  }\n}\n\n// good - constructor 不一定要使用this\nclass Foo {\n  constructor() {\n    // ...\n  }\n}\n\n// good - 静态方法不需要使用 this\nclass Foo {\n  static bar() {\n    console.log('bar');\n  }\n}\n```\n\n### Modules\n\n#### 10.1 用(`import/export`) 模块而不是无标准的模块系统。你可以随时转到你喜欢的模块系统。\n\n> Why? 模块化是未来，让我们现在就开启未来吧。\n\n```javascript\n// bad\nconst AirbnbStyleGuide = require('./AirbnbStyleGuide');\nmodule.exports = AirbnbStyleGuide.es6;\n\n// ok\nimport AirbnbStyleGuide from './AirbnbStyleGuide';\nexport default AirbnbStyleGuide.es6;\n\n// best\nimport { es6 } from './AirbnbStyleGuide';\nexport default es6;\n```\n\n#### 10.2 不要用import通配符， 就是 * 这种方式\n\n> Why? 这确保你有单个默认的导出\n\n```javascript\n// bad\nimport * as AirbnbStyleGuide from './AirbnbStyleGuide';\n\n// good\nimport AirbnbStyleGuide from './AirbnbStyleGuide';\n```\n\n#### 10.3 不要直接从`import`中直接`export`\n\n> Why? 虽然一行是简洁的，有一个明确的方式进口和一个明确的出口方式来保证一致性。\n\n```javascript\n// bad\n// filename es6.js\nexport { es6 as default } from './AirbnbStyleGuide';\n\n// good\n// filename es6.js\nimport { es6 } from './AirbnbStyleGuide';\nexport default es6;\n```\n\n#### 10.4 一个路径只 `import` 一次。 eslint: `no-duplicate-imports`\n\n> Why? 从同一个路径下import多行会使代码难以维护\n\n```javascript\n// bad\nimport foo from 'foo';\n// … some other imports … //\nimport { named1, named2 } from 'foo';\n\n// good\nimport foo, { named1, named2 } from 'foo';\n\n// good\nimport foo, {\n  named1,\n  named2,\n} from 'foo';\n```\n\n#### 10.5 不要导出可变的东西 eslint: `import/no-mutable-exports`\n\n> Why? 变化通常都是需要避免，特别是当你要输出可变的绑定。虽然在某些场景下可能需要这种技术，但总的来说应该导出常量。\n\n```javascript\n// bad\nlet foo = 3;\nexport { foo }\n\n// good\nconst foo = 3;\nexport { foo }\n```\n\n#### 10.6 在一个单一导出模块里，用 `export default` 更好。 eslint: `import/prefer-default-export`\n\n> Why? 鼓励使用更多文件，每个文件只做一件事情并导出，这样可读性和可维护性更好。\n\n```javascript\n// bad\nexport function foo() {}\n\n// good\nexport default function foo() {}\n```\n\n#### 10.7 import 放在其他所有语句之前。 eslint: `import/first`\n\n> Why? 让import放在最前面防止意外行为。\n\n```javascript\n// bad\nimport foo from 'foo';\nfoo.init();\n\nimport bar from 'bar';\n\n// good\nimport foo from 'foo';\nimport bar from 'bar';\n\nfoo.init();\n```\n\n#### 10.8 多行`import`应该缩进，就像多行数组和对象字面量\n\n> Why? 花括号与样式指南中每个其他花括号块遵循相同的缩进规则，逗号也是。\n\n```javascript\n// bad\nimport {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';\n\n// good\nimport {\n  longNameA,\n  longNameB,\n  longNameC,\n  longNameD,\n  longNameE,\n} from 'path';\n```\n\n####  10.9 在import语句里不允许Webpack loader语法 eslint: `import/no-webpack-loader-syntax`\n\n> Why? 一旦用Webpack语法在import里会把代码耦合到模块绑定器。最好是在webpack.config.js里写webpack loader语法\n\n```javascript\n// bad\nimport fooSass from 'css!sass!foo.scss';\nimport barCss from 'style!css!bar.css';\n\n// good\nimport fooSass from 'foo.scss';\nimport barCss from 'bar.css';\n```\n\n### Iterators and Generators\n\n#### 11.1 不要用遍历器。用JavaScript高级函数代替for-in、 for-of。 eslint: `no-iterator no-restricted-syntax`\n\n> Why? 这强调了我们不可变的规则。 处理返回值的纯函数比副作用更容易。\n\n> Why?用数组的这些迭代方法： \n>  - map()\n>  - every()\n>  - filter() \n>  - find()\n>  - findIndex()\n>  - reduce()\n>  - some()\n>  - ... , \n>\n>  用对象的这些方法 \n>  - Object.keys()\n>  - Object.values()\n>  - Object.entries() \n>\n>  去产生一个数组， 这样你就能去遍历对象了。\n>\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// bad\nlet sum = 0;\nfor (let num of numbers) {\n  sum += num;\n}\nsum === 15;\n\n// good\nlet sum = 0;\nnumbers.forEach(num => sum += num);\nsum === 15;\n\n// best (use the functional force)\nconst sum = numbers.reduce((total, num) => total + num, 0);\nsum === 15;\n\n// bad\nconst increasedByOne = [];\nfor (let i = 0; i < numbers.length; i++) {\n  increasedByOne.push(numbers[i] + 1);\n}\n\n// good\nconst increasedByOne = [];\nnumbers.forEach(num => increasedByOne.push(num + 1));\n\n// best (keeping it functional)\nconst increasedByOne = numbers.map(num => num + 1);\n```\n\n#### 11.2 现在不要用generator\n\n> Why? 它在es5上支持的不好\n\n#### 11.3 如果你一定要用，或者你忽略我们的建议, 请确保它们的函数签名空格是得当的。 eslint: `generator-star-spacing`\n\n> Why? function 和 * 是同一概念关键字 - *不是function的修饰符，function*是一个和function不一样的独特结构\n\n```javascript\n// bad\nfunction * foo() {\n  // ...\n}\n\n// bad\nconst bar = function * () {\n  // ...\n}\n\n// bad\nconst baz = function *() {\n  // ...\n}\n\n// bad\nconst quux = function*() {\n  // ...\n}\n\n// bad\nfunction*foo() {\n  // ...\n}\n\n// bad\nfunction *foo() {\n  // ...\n}\n\n// very bad\nfunction\n*\nfoo() {\n  // ...\n}\n\n// very bad\nconst wat = function\n*\n() {\n  // ...\n}\n\n// good\nfunction* foo() {\n  // ...\n}\n\n// good\nconst foo = function* () {\n  // ...\n}\n```\n\n### Properties\n\n#### 12.1 访问属性时使用点符号. eslint: `dot-notation`\n\n```javascript\nconst luke = {\n  jedi: true,\n  age: 28,\n};\n\n// bad\nconst isJedi = luke['jedi'];\n\n// good\nconst isJedi = luke.jedi;\n```\n\n#### 12.2 当获取的属性是变量时用方括号`[]`取。\n\n```javascript\nconst luke = {\n  jedi: true,\n  age: 28,\n};\n\nfunction getProp(prop) {\n  return luke[prop];\n}\n\nconst isJedi = getProp('jedi');\n```\n\n#### 12.3 做幂运算时用幂操作符 `**` 。 eslint: `no-restricted-properties`.\n\n```javascript\n// bad\nconst binary = Math.pow(2, 10);\n\n// good\nconst binary = 2 ** 10;\n```\n\n### Variables\n\n#### 13.1 用`const`或`let`声明变量。不这样做会导致全局变量。 我们想要避免污染全局命名空间。首长这样警告我们。 eslint: `no-undef` `prefer-const`\n\n```javascript\n// bad\nsuperPower = new SuperPower();\n\n// good\nconst superPower = new SuperPower();\n```\n\n#### 13.2 每个变量都用一个 const 或 let 。 eslint: `one-var`\n\n> Why? 这种方式很容易去声明新的变量，你不用去考虑把;调换成,，或者引入一个只有标点的不同的变化。这种做法也可以是你在调试的时候单步每个声明语句，而不是一下跳过所有声明。\n\n```javascript\n// bad\nconst items = getItems(),\n    goSportsTeam = true,\n    dragonball = 'z';\n\n// bad\n// (compare to above, and try to spot the mistake)\nconst items = getItems(),\n    goSportsTeam = true;\n    dragonball = 'z';\n\n// good\nconst items = getItems();\nconst goSportsTeam = true;\nconst dragonball = 'z';\n```\n\n#### 13.3 const放一起，let放一起\n\n> Why? 在你需要分配一个新的变量， 而这个变量依赖之前分配过的变量的时候，这种做法是有帮助的\n\n```javascript\n// bad\nlet i, len, dragonball,\n    items = getItems(),\n    goSportsTeam = true;\n\n// bad\nlet i;\nconst items = getItems();\nlet dragonball;\nconst goSportsTeam = true;\nlet len;\n\n// good\nconst goSportsTeam = true;\nconst items = getItems();\nlet dragonball;\nlet i;\nlet length;\n```\n\n#### 13.4 在你需要的地方声明变量，但是要放在合理的位置\n\n> Why? let 和 const 都是块级作用域而不是函数级作用域\n\n```javascript\n// bad - unnecessary function call\nfunction checkName(hasName) {\n  const name = getName();\n\n  if (hasName === 'test') {\n    return false;\n  }\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n\n// good\nfunction checkName(hasName) {\n  if (hasName === 'test') {\n    return false;\n  }\n\n  // 在需要的时候分配\n  const name = getName();\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n```\n\n#### 13.5 不要使用链接变量分配。 eslint: `no-multi-assign`\n\n> Why? 链接变量分配创建隐式全局变量。\n\n```javascript\n// bad\n(function example() {\n  // JavaScript 将这一段解释为\n  // let a = ( b = ( c = 1 ) );\n  // let 只对变量 a 起作用; 变量 b 和 c 都变成了全局变量\n  let a = b = c = 1;\n}());\n\nconsole.log(a); // undefined\nconsole.log(b); // 1\nconsole.log(c); // 1\n\n// good\n(function example() {\n  let a = 1;\n  let b = a;\n  let c = a;\n}());\n\nconsole.log(a); // undefined\nconsole.log(b); // undefined\nconsole.log(c); // undefined\n\n// `const` 也是如此\n```\n\n#### 13.6 不要使用一元自增自减运算符（++， --）. eslint: `no-plusplus`\n\n> Why? 根据eslint文档，一元增量和减量语句受到自动分号插入的影响，并且可能会导致应用程序中的值递增或递减的无声错误。 使用num + = 1而不是num ++或num ++语句来表达你的值也是更有表现力的。 禁止一元增量和减量语句还会阻止您无意地预增/预减值，这也会导致程序出现意外行为。\n\n```javascript\n // bad\n\n  const array = [1, 2, 3];\n  let num = 1;\n  num++;\n  --num;\n\n  let sum = 0;\n  let truthyCount = 0;\n  for (let i = 0; i < array.length; i++) {\n    let value = array[i];\n    sum += value;\n    if (value) {\n      truthyCount++;\n    }\n  }\n\n  // good\n\n  const array = [1, 2, 3];\n  let num = 1;\n  num += 1;\n  num -= 1;\n\n  const sum = array.reduce((a, b) => a + b, 0);\n  const truthyCount = array.filter(Boolean).length;\n```\n\n#### 13.7 在赋值的时候避免在 = 前/后换行。 如果你的赋值语句超出 max-len， 那就用小括号把这个值包起来再换行。 eslint: `operator-linebreak`.\n\n> Why? 在 = 附近换行容易混淆这个赋值语句。\n\n```javascript\n// bad\nconst foo =\n  superLongLongLongLongLongLongLongLongFunctionName();\n\n// bad\nconst foo\n  = 'superLongLongLongLongLongLongLongLongString';\n\n// good\nconst foo = (\n  superLongLongLongLongLongLongLongLongFunctionName()\n);\n\n// good\nconst foo = 'superLongLongLongLongLongLongLongLongString';\n```\n\n#### 13.8 不允许有未使用的变量。 eslint: `no-unused-vars`\n\n> Why? 一个声明了但未使用的变量更像是由于重构未完成产生的错误。这种在代码中出现的变量会使阅读者迷惑。\n\n```javascript\n// bad\n\nvar some_unused_var = 42;\n\n// 写了没用\nvar y = 10;\ny = 5;\n\n// 变量改了自己的值，也没有用这个变量\nvar z = 0;\nz = z + 1;\n\n// 参数定义了但未使用\nfunction getX(x, y) {\n    return x;\n}\n\n// good\nfunction getXPlusY(x, y) {\n  return x + y;\n}\n\nvar x = 1;\nvar y = a + 2;\n\nalert(getXPlusY(x, y));\n\n// 'type' 即使没有使用也可以可以被忽略， 因为这个有一个 rest 取值的属性。\n// 这是从对象中抽取一个忽略特殊字段的对象的一种形式\nvar { type, ...coords } = data;\n// 'coords' 现在就是一个没有 'type' 属性的 'data' 对象\n```\n\n### Hoisting\n\n#### 14.1 var声明会被提前到他的作用域的最前面，它分配的值还没有提前。const 和 let被赋予了新的调用概念时效区 —— Temporal Dead Zones (TDZ)。 重要的是要知道为什么 typeof不再安全.\n\n```javascript\n// 我们知道这个不会工作，假设没有定义全局的notDefined\nfunction example() {\n  console.log(notDefined); // => throws a ReferenceError\n}\n\n// 在你引用的地方之后声明一个变量，他会正常输出是因为变量作用域上升。\n// 注意： declaredButNotAssigned的值没有上升\nfunction example() {\n  console.log(declaredButNotAssigned); // => undefined\n  var declaredButNotAssigned = true;\n}\n\n// 解释器把变量声明提升到作用域最前面，\n// 可以重写成如下例子， 二者意义相同\nfunction example() {\n  let declaredButNotAssigned;\n  console.log(declaredButNotAssigned); // => undefined\n  declaredButNotAssigned = true;\n}\n\n// 用 const， let就不一样了\nfunction example() {\n  console.log(declaredButNotAssigned); // => throws a ReferenceError\n  console.log(typeof declaredButNotAssigned); // => throws a ReferenceError\n  const declaredButNotAssigned = true;\n}\n```\n\n#### 14.2 匿名函数表达式和 `var` 情况相同\n\n```javascript\nfunction example() {\n  console.log(anonymous); // => undefined\n\n  anonymous(); // => TypeError anonymous is not a function\n\n  var anonymous = function () {\n    console.log('anonymous function expression');\n  };\n}\n```\n\n#### 14.3 已命名函数表达式提升他的变量名，不是函数名或函数体\n\n```javascript\nfunction example() {\n  console.log(named); // => undefined\n\n  named(); // => TypeError named is not a function\n\n  superPower(); // => ReferenceError superPower is not defined\n\n  var named = function superPower() {\n    console.log('Flying');\n  };\n}\n\n// 函数名和变量名一样是也如此\nfunction example() {\n  console.log(named); // => undefined\n\n  named(); // => TypeError named is not a function\n\n  var named = function named() {\n    console.log('named');\n  };\n}\n```\n\n#### 14.4 函数声明则提升了函数名和函数体\n```javascript\nfunction example() {\n  superPower(); // => Flying\n\n  function superPower() {\n    console.log('Flying');\n  }\n}\n```\n\n### Comparison Operators & Equality\n\n#### 15.1 用 === 和 !== 而不是 == 和 !=. eslint: `eqeqeq`\n\n#### 15.2 条件语句如'if'语句使用强制`ToBoolean'抽象方法来评估它们的表达式，并且始终遵循以下简单规则：\n- Objects 计算成 true\n- Undefined 计算成 false\n- Null 计算成 false\n- Booleans 计算成 the value of the boolean\n- Numbers\n- +0, -0, or NaN 计算成 false\n- 其他 true\n- Strings\n- '' 计算成 false\n- 其他 true\n\n```javascript\nif ([0] && []) {\n  // true\n  // 数组（即使是空数组）是对象，对象会计算成true\n}\n```\n\n#### 15.3 布尔值用缩写，而字符串和数字要明确比较对象\n\n```javascript\n// bad\nif (isValid === true) {\n  // ...\n}\n\n// good\nif (isValid) {\n  // ...\n}\n\n// bad\nif (name) {\n  // ...\n}\n\n// good\nif (name !== '') {\n  // ...\n}\n\n// bad\nif (collection.length) {\n  // ...\n}\n\n// good\nif (collection.length > 0) {\n  // ...\n}\n```\n\n#### 15.4 更多信息请见Angus Croll的真理、平等和JavaScript —— Truth Equality and JavaScript\n\n#### 15.5 在`case`和`default`分句里用大括号创建一块包含语法声明的区域(e.g. `let`, `const`, `function`, and `class`). eslint: `no-case-declarations`.\n\n> Why? 语法声明在整个switch的代码块里都可见，但是只有当其被分配后才会初始化，他的初始化时当这个case被执行时才产生。 当多个case分句试图定义同一个事情时就出问题了\n\n```javascript\n// bad\nswitch (foo) {\n  case 1:\n    let x = 1;\n    break;\n  case 2:\n    const y = 2;\n    break;\n  case 3:\n    function f() {\n      // ...\n    }\n    break;\n  default:\n    class C {}\n}\n\n// good\nswitch (foo) {\n  case 1: {\n    let x = 1;\n    break;\n  }\n  case 2: {\n    const y = 2;\n    break;\n  }\n  case 3: {\n    function f() {\n      // ...\n    }\n    break;\n  }\n  case 4:\n    bar();\n    break;\n  default: {\n    class C {}\n  }\n}\n```\n\n#### 15.6 三元表达式不应该嵌套，通常是单行表达式。eslint: `no-nested-ternary`.\n\n```javascript\n// bad\nconst foo = maybe1 > maybe2\n  ? \"bar\"\n  : value1 > value2 ? \"baz\" : null;\n\n// better\nconst maybeNull = value1 > value2 ? 'baz' : null;\n\nconst foo = maybe1 > maybe2\n  ? 'bar'\n  : maybeNull;\n\n// best\nconst maybeNull = value1 > value2 ? 'baz' : null;\n\nconst foo = maybe1 > maybe2 ? 'bar' : maybeNull;\n```\n\n#### 15.7 避免不需要的三元表达式。 eslint: `no-unneeded-ternary`.\n\n```javascript\n// bad\nconst foo = a ? a : b;\nconst bar = c ? true : false;\nconst baz = c ? false : true;\n\n// good\nconst foo = a || b;\nconst bar = !!c;\nconst baz = !c;\n```\n\n#### 15.8 用圆括号来混合这些操作符。 只有当标准的算术运算符(+, -, *, & /)， 并且它们的优先级显而易见时，可以不用圆括号括起来。 eslint: `no-mixed-operators`\n\n> Why? 这提高了可读性，并且明确了开发者的意图\n\n```javascript\n// bad\nconst foo = a && b < 0 || c > 0 || d + 1 === 0;\n\n// bad\nconst bar = a ** b - 5 % d;\n\n// bad\n// 别人会陷入(a || b) && c 的迷惑中\nif (a || b && c) {\n  return d;\n}\n\n// good\nconst foo = (a && b < 0) || c > 0 || (d + 1 === 0);\n\n// good\nconst bar = (a ** b) - (5 % d);\n\n// good\nif (a || (b && c)) {\n  return d;\n}\n\n// good\nconst bar = a + b / c * d;\n```\n\n### Blocks\n\n#### 16.1 用大括号包裹多行代码块。 eslint: `nonblock-statement-body-position`\n\n```javascript\n// bad\nif (test)\n  return false;\n\n// good\nif (test) return false;\n\n// good\nif (test) {\n  return false;\n}\n\n// bad\nfunction foo() { return false; }\n\n// good\nfunction bar() {\n  return false;\n}\n```\n\n#### 16.2 if表达式的else和if的关闭大括号在一行。 eslint: `brace-style`\n\n```javascript\n// bad\nif (test) {\n  thing1();\n  thing2();\n}\nelse {\n  thing3();\n}\n\n// good\nif (test) {\n  thing1();\n  thing2();\n} else {\n  thing3();\n}\n```\n\n#### 16.3 如果 if 语句中总是需要用 return 返回， 那后续的 else 就不需要写了。 if 块中包含 return， 它后面的 else if 块中也包含了 return， 这个时候就可以把 return 分到多个 if 语句块中。 eslint: `no-else-return`\n\n```javascript\n// bad\nfunction foo() {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\n// bad\nfunction cats() {\n  if (x) {\n    return x;\n  } else if (y) {\n    return y;\n  }\n}\n\n// bad\nfunction dogs() {\n  if (x) {\n    return x;\n  } else {\n    if (y) {\n      return y;\n    }\n  }\n}\n\n// good\nfunction foo() {\n  if (x) {\n    return x;\n  }\n\n  return y;\n}\n\n// good\nfunction cats() {\n  if (x) {\n    return x;\n  }\n\n  if (y) {\n    return y;\n  }\n}\n\n// good\nfunction dogs(x) {\n  if (x) {\n    if (z) {\n      return y;\n    }\n  } else {\n    return z;\n  }\n}\n```\n\n### Control Statements\n\n#### 17.1 当你的控制语句(if, while 等)太长或者超过最大长度限制的时候， 把每一个(组)判断条件放在单独一行里。 逻辑操作符放在行首。\n\n> Why? 把逻辑操作符放在行首是让操作符的对齐方式和链式函数保持一致。这提高了可读性，也让复杂逻辑更容易看清楚。\n\n```javascript\n// bad\nif ((foo === 123 || bar === 'abc') && doesItLookGoodWhenItBecomesThatLong() && isThisReallyHappening()) {\n  thing1();\n}\n\n// bad\nif (foo === 123 &&\n  bar === 'abc') {\n  thing1();\n}\n\n// bad\nif (foo === 123\n  && bar === 'abc') {\n  thing1();\n}\n\n// bad\nif (\n  foo === 123 &&\n  bar === 'abc'\n) {\n  thing1();\n}\n\n// good\nif (\n  foo === 123\n  && bar === 'abc'\n) {\n  thing1();\n}\n\n// good\nif (\n  (foo === 123 || bar === 'abc')\n  && doesItLookGoodWhenItBecomesThatLong()\n  && isThisReallyHappening()\n) {\n  thing1();\n}\n\n// good\nif (foo === 123 && bar === 'abc') {\n  thing1();\n}\n```\n\n#### 17.2 不要用选择操作符代替控制语句。\n\n```javascript\n// bad\n!isRunning && startRunning();\n\n// good\nif (!isRunning) {\n  startRunning();\n}\n```\n\n### Comments\n\n#### 18.1 多行注释用 `/** ... */`\n\n```javascript\n// bad\n// make() returns a new element\n// based on the passed in tag name\n//\n// @param {String} tag\n// @return {Element} element\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n\n// good\n/**\n * make() returns a new element\n * based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n```\n\n#### 18.2 单行注释用`//`，将单行注释放在被注释区域上面。如果注释不是在第一行，那么注释前面就空一行\n\n```javascript\n// bad\nconst active = true;  // is current tab\n\n// good\n// is current tab\nconst active = true;\n\n// bad\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  const type = this._type || 'no type';\n\n  return type;\n}\n\n// good\nfunction getType() {\n  console.log('fetching type...');\n\n  // set the default type to 'no type'\n  const type = this._type || 'no type';\n\n  return type;\n}\n\n// also good\nfunction getType() {\n  // set the default type to 'no type'\n  const type = this._type || 'no type';\n\n  return type;\n}\n```\n\n#### 18.3 所有注释开头空一个，方便阅读。 eslint: `spaced-comment`\n\n```javascript\n// bad\n//is current tab\nconst active = true;\n\n// good\n// is current tab\nconst active = true;\n\n// bad\n/**\n *make() returns a new element\n *based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n\n// good\n/**\n * make() returns a new element\n * based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n```\n\n#### 18.4 在你的注释前使用FIXME'或TODO'前缀， 这有助于其他开发人员快速理解你指出的需要重新访问的问题， 或者您建议需要实现的问题的解决方案。 这些不同于常规注释，因为它们是可操作的。 动作是FIXME： - 需要计算出来或TODO： - 需要实现。\n\n#### 18.5 用`// FIXME:`给问题做注释\n\n```javascript\nclass Calculator extends Abacus {\n  constructor() {\n    super();\n\n    // FIXME: shouldn't use a global here\n    total = 0;\n  }\n}\n```\n\n#### 18.6 用`// TODO:`去注释问题的解决方案\n\n```javascript\nclass Calculator extends Abacus {\n  constructor() {\n    super();\n\n    // TODO: total should be configurable by an options param\n    this.total = 0;\n  }\n}\n```\n\n### Whitespace\n\n#### 19.1 tab用两个空格. eslint: `indent`\n\n```javascript\n// bad\nfunction foo() {\n∙∙∙∙const name;\n}\n\n// bad\nfunction bar() {\n∙const name;\n}\n\n// good\nfunction baz() {\n∙∙const name;\n}\n```\n\n#### 19.2 在大括号前空一格。 eslint: `space-before-blocks`\n\n```javascript\n// bad\nfunction test(){\n  console.log('test');\n}\n\n// good\nfunction test() {\n  console.log('test');\n}\n\n// bad\ndog.set('attr',{\n  age: '1 year',\n  breed: 'Bernese Mountain Dog',\n});\n\n// good\ndog.set('attr', {\n  age: '1 year',\n  breed: 'Bernese Mountain Dog',\n});\n```\n\n#### 19.3 在控制语句(if, while 等)的圆括号前空一格。在函数调用和定义时，参数列表和函数名之间不空格。 eslint: `keyword-spacing`\n\n```javascript\n// bad\nif(isJedi) {\n  fight ();\n}\n\n// good\nif (isJedi) {\n  fight();\n}\n\n// bad\nfunction fight () {\n  console.log ('Swooosh!');\n}\n\n// good\nfunction fight() {\n  console.log('Swooosh!');\n}\n```\n\n#### 19.4 用空格来隔开运算符。 eslint: `space-infix-ops`\n\n```javascript\n// bad\nconst x=y+5;\n\n// good\nconst x = y + 5;\n```\n\n#### 19.5 文件结尾空一行. eslint: `eol-last`\n\n```javascript\n// bad\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;\n```\n\n```javascript\n// bad\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;↵\n↵\n```\n\n```javascript\n// good\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;↵\n```\n\n#### 19.6 当出现长的方法链（>2个）时用缩进。用点开头强调该行是一个方法调用，而不是一个新的语句。eslint: `newline-per-chained-call` `no-whitespace-before-property`\n\n```javascript\n// bad\n$('#items').find('.selected').highlight().end().find('.open').updateCount();\n\n// bad\n$('#items').\n  find('.selected').\n    highlight().\n    end().\n  find('.open').\n    updateCount();\n\n// good\n$('#items')\n  .find('.selected')\n    .highlight()\n    .end()\n  .find('.open')\n    .updateCount();\n\n// bad\nconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true)\n    .attr('width', (radius + margin) * 2).append('svg:g')\n    .attr('transform', `translate(${radius + margin},${radius + margin})`)\n    .call(tron.led);\n\n// good\nconst leds = stage.selectAll('.led')\n    .data(data)\n  .enter().append('svg:svg')\n    .classed('led', true)\n    .attr('width', (radius + margin) * 2)\n  .append('svg:g')\n    .attr('transform', `translate(${radius + margin},${radius + margin})`)\n    .call(tron.led);\n\n// good\nconst leds = stage.selectAll('.led').data(data);\n```\n\n#### 19.7 在一个代码块后下一条语句前空一行。\n\n```javascript\n// bad\nif (foo) {\n  return bar;\n}\nreturn baz;\n\n// good\nif (foo) {\n  return bar;\n}\n\nreturn baz;\n\n// bad\nconst obj = {\n  foo() {\n  },\n  bar() {\n  },\n};\nreturn obj;\n\n// good\nconst obj = {\n  foo() {\n  },\n\n  bar() {\n  },\n};\n\nreturn obj;\n\n// bad\nconst arr = [\n  function foo() {\n  },\n  function bar() {\n  },\n];\nreturn arr;\n\n// good\nconst arr = [\n  function foo() {\n  },\n\n  function bar() {\n  },\n];\n\nreturn arr;\n```\n\n#### 19.8 不要用空白行填充块。 eslint: `padded-blocks`\n\n```javascript\n// bad\nfunction bar() {\n\n  console.log(foo);\n\n}\n\n// also bad\nif (baz) {\n\n  console.log(qux);\n} else {\n  console.log(foo);\n\n}\n\n// good\nfunction bar() {\n  console.log(foo);\n}\n\n// good\nif (baz) {\n  console.log(qux);\n} else {\n  console.log(foo);\n}\n```\n\n#### 19.9不要在代码之间使用多个空白行填充。 eslint: `no-multiple-empty-lines`\n\n```javascript\n// bad\nclass Person {\n  constructor(fullName, email, birthday) {\n    this.fullName = fullName;\n\n\n    this.email = email;\n\n\n    this.setAge(birthday);\n  }\n\n\n  setAge(birthday) {\n    const today = new Date();\n\n\n    const age = this.getAge(today, birthday);\n\n\n    this.age = age;\n  }\n\n\n  getAge(today, birthday) {\n    // ..\n  }\n}\n\n// good\nclass Person {\n  constructor(fullName, email, birthday) {\n    this.fullName = fullName;\n    this.email = email;\n    this.setAge(birthday);\n  }\n\n  setAge(birthday) {\n    const today = new Date();\n    const age = getAge(today, birthday);\n    this.age = age;\n  }\n\n  getAge(today, birthday) {\n    // ..\n  }\n}\n```\n\n#### 19.10 圆括号里不要加空格。 eslint: `space-in-parens`\n\n```javascript\n// bad\nfunction bar( foo ) {\n  return foo;\n}\n\n// good\nfunction bar(foo) {\n  return foo;\n}\n\n// bad\nif ( foo ) {\n  console.log(foo);\n}\n\n// good\nif (foo) {\n  console.log(foo);\n}\n```\n\n#### 19.11 方括号里不要加空格。看示例。 eslint: `array-bracket-spacing`\n\n```javascript\n// bad\nconst foo = [ 1, 2, 3 ];\nconsole.log(foo[ 0 ]);\n\n// good， 逗号分隔符还是要空格的\nconst foo = [1, 2, 3];\nconsole.log(foo[0]);\n```\n\n#### 19.12 花括号里加空格。 eslint: `object-curly-spacing`\n\n```javascript\n// bad\nconst foo = {clark: 'kent'};\n\n// good\nconst foo = { clark: 'kent' };\n```\n\n#### 19.13 避免一行代码超过100个字符（包含空格）。\n\n> 注意： 对于上面——strings--line-length，长字符串不受此规则限制，不应分解。 eslint: `max-len`\n\n> Why? 这样确保可读性和可维护性\n\n```javascript\n// bad\nconst foo = jsonData && jsonData.foo && jsonData.foo.bar && jsonData.foo.bar.baz && jsonData.foo.bar.baz.quux && jsonData.foo.bar.baz.quux.xyzzy;\n\n// bad\n$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() => console.log('Congratulations!')).fail(() => console.log('You have failed this city.'));\n\n// good\nconst foo = jsonData\n  && jsonData.foo\n  && jsonData.foo.bar\n  && jsonData.foo.bar.baz\n  && jsonData.foo.bar.baz.quux\n  && jsonData.foo.bar.baz.quux.xyzzy;\n\n// good\n$.ajax({\n  method: 'POST',\n  url: 'https://airbnb.com/',\n  data: { name: 'John' },\n})\n  .done(() => console.log('Congratulations!'))\n  .fail(() => console.log('You have failed this city.'));\n```\n\n#### 19.14 作为语句的花括号内也要加空格 —— { 后和 } 前都需要空格。 eslint: `block-spacing`\n\n```javascript\n// bad\nfunction foo() {return true;}\nif (foo) { bar = 0;}\n\n// good\nfunction foo() { return true; }\nif (foo) { bar = 0; }\n```\n\n#### 19.15 `,` 前不要空格， `,` 后需要空格。 eslint: `comma-spacing`\n\n```javascript\n// bad\nvar foo = 1,bar = 2;\nvar arr = [1 , 2];\n\n// good\nvar foo = 1, bar = 2;\nvar arr = [1, 2];\n```\n\n#### 19.16 计算属性内要空格。参考上述花括号和中括号的规则。 eslint: `computed-property-spacing`\n\n```javascript\n// bad\nobj[foo ]\nobj[ 'foo']\nvar x = {[ b ]: a}\nobj[foo[ bar ]]\n\n// good\nobj[foo]\nobj['foo']\nvar x = { [b]: a }\nobj[foo[bar]]\n```\n\n#### 19.17 调用函数时，函数名和小括号之间不要空格。 eslint: `func-call-spacing`\n\n```javascript\n// bad\nfunc ();\n\nfunc\n();\n\n// good\nfunc();\n```\n\n#### 19.18 在对象的字面量属性中， `key` `value` 之间要有空格。 eslint: `key-spacing`\n\n```javascript\n// bad\nvar obj = { \"foo\" : 42 };\nvar obj2 = { \"foo\":42 };\n\n// good\nvar obj = { \"foo\": 42 };\n```\n\n#### 19.19 行末不要空格。 eslint: `no-trailing-spaces`\n\n#### 19.20 避免出现多个空行。 在文件末尾只允许空一行。 eslint: `no-multiple-empty-lines`\n\n```javascript\n// bad\nvar x = 1;\n\n\n\nvar y = 2;\n\n// good\nvar x = 1;\n\nvar y = 2;\n```\n\n### Commas\n\n#### 20.1 不要前置逗号。 eslint: `comma-style`\n\n```javascript\n// bad\nconst story = [\n    once\n  , upon\n  , aTime\n];\n\n// good\nconst story = [\n  once,\n  upon,\n  aTime,\n];\n\n// bad\nconst hero = {\n    firstName: 'Ada'\n  , lastName: 'Lovelace'\n  , birthYear: 1815\n  , superPower: 'computers'\n};\n\n// good\nconst hero = {\n  firstName: 'Ada',\n  lastName: 'Lovelace',\n  birthYear: 1815,\n  superPower: 'computers',\n};\n```\n\n#### 20.2 额外结尾逗号: 要 eslint: `comma-dangle`\n\n> Why? 这导致git diffs更清洁。 此外，像Babel这样的转换器会删除转换代码中的额外的逗号，这意味着你不必担心旧版浏览器中的结尾逗号问题。\n\n```javascript\n// bad - 没有结尾逗号的 git diff\nconst hero = {\n     firstName: 'Florence',\n-    lastName: 'Nightingale'\n+    lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing']\n};\n\n// good - 有结尾逗号的 git diff\nconst hero = {\n     firstName: 'Florence',\n     lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing'],\n};\n```\n\n```javascript\n// bad\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully'\n};\n\nconst heroes = [\n  'Batman',\n  'Superman'\n];\n\n// good\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully',\n};\n\nconst heroes = [\n  'Batman',\n  'Superman',\n];\n\n// bad\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf\n) {\n  // does nothing\n}\n\n// good\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf,\n) {\n  // does nothing\n}\n\n// good (note that a comma must not appear after a \"rest\" element)\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf,\n  ...heroArgs\n) {\n  // does nothing\n}\n\n// bad\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf\n);\n\n// good\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf,\n);\n\n// good (note that a comma must not appear after a \"rest\" element)\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf,\n  ...heroArgs\n)\n```\n\n### Semicolons\n\n#### 21.1 Yup. eslint: `semi`\n\n> Why? 当 JavaScript 遇到没有分号结尾的一行，它会执行自动插入分号 Automatic Semicolon Insertion这一规则来决定行末是否加分号。如果JavaScript在你的断行里错误的插入了分号，就会出现一些古怪的行为。当新的功能加到JavaScript里后， 这些规则会变得更复杂难懂。显示的结束语句，并通过配置代码检查去捕获没有带分号的地方可以帮助你防止这种错误。\n\n```javascript\n// bad\n(function () {\n  const name = 'Skywalker'\n  return name\n})()\n\n// good\n(function () {\n  const name = 'Skywalker';\n  return name;\n}());\n\n// good, 行首加分号，避免文件被连接到一起时立即执行函数被当做变量来执行。\n;(() => {\n  const name = 'Skywalker';\n  return name;\n}());\n```\n\n### Type Casting & Coercion\n\n#### 22.1 在语句开始执行强制类型转换。\n\n#### 22.2 Strings: eslint: `no-new-wrappers`\n\n```javascript\n// => this.reviewScore = 9;\n\n// bad\nconst totalScore = new String(this.reviewScore); // typeof totalScore is \"object\" not \"string\"\n\n// bad\nconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()\n\n// bad\nconst totalScore = this.reviewScore.toString(); // 不保证返回string\n\n// good\nconst totalScore = String(this.reviewScore);\n```\n\n#### 22.3 Numbers: 用 `Number` 做类型转换，`parseInt`转换string常需要带上基数。 eslint: `radix`\n\n```javascript\nconst inputValue = '4';\n\n// bad\nconst val = new Number(inputValue);\n\n// bad\nconst val = +inputValue;\n\n// bad\nconst val = inputValue >> 0;\n\n// bad\nconst val = parseInt(inputValue);\n\n// good\nconst val = Number(inputValue);\n\n// good\nconst val = parseInt(inputValue, 10);\n```\n\n#### 22.4 请在注释中解释为什么要用移位运算和你在做什么。无论你做什么狂野的事，比如由于 `parseInt` 是你的性能瓶颈导致你一定要用移位运算。 请说明这个是因为性能原因,\n\n```javascript\n// good\n/**\n * parseInt是代码运行慢的原因\n * 用Bitshifting将字符串转成数字使代码运行效率大幅增长\n */\nconst val = inputValue >> 0;\n```\n\n#### 22.5 注意: 用移位运算要小心. 数字使用64-位表示的，但移位运算常常返回的是32为整形source)。移位运算对大于32位的整数会导致意外行为。Discussion. 最大的32位整数是 2,147,483,647:\n\n```javascript\n2147483647 >> 0 //=> 2147483647\n2147483648 >> 0 //=> -2147483648\n2147483649 >> 0 //=> -2147483647\n```\n\n#### 22.6 布尔:\n\n```javascript\nconst age = 0;\n\n// bad\nconst hasAge = new Boolean(age);\n\n// good\nconst hasAge = Boolean(age);\n\n// best\nconst hasAge = !!age;\n```\n\n### Naming Conventions\n\n#### 23.1 避免用一个字母命名，让你的命名可描述。 eslint: `id-length`\n\n```javascript\n// bad\nfunction q() {\n  // ...\n}\n\n// good\nfunction query() {\n  // ...\n}\n```\n\n#### 23.2 用小驼峰式命名你的对象、函数、实例。 eslint: `camelcase`\n\n```javascript\n// bad\nconst OBJEcttsssss = {};\nconst this_is_my_object = {};\nfunction c() {}\n\n// good\nconst thisIsMyObject = {};\nfunction thisIsMyFunction() {}\n```\n\n#### 23.3 用大驼峰式命名类。 eslint: `new-cap`\n\n```javascript\n// bad\nfunction user(options) {\n  this.name = options.name;\n}\n\nconst bad = new user({\n  name: 'nope',\n});\n\n// good\nclass User {\n  constructor(options) {\n    this.name = options.name;\n  }\n}\n\nconst good = new User({\n  name: 'yup',\n});\n```\n\n#### 23.4 不要用前置或后置下划线。 eslint: `no-underscore-dangle`\n\n> Why? JavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着“private”，事实上，这些属性是完全公有的，因此这部分也是你的API的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。 如果你想要什么东西变成“private”，那就不要让它在这里出现。\n\n```javascript\n// bad\nthis.__firstName__ = 'Panda';\nthis.firstName_ = 'Panda';\nthis._firstName = 'Panda';\n\n// good\nthis.firstName = 'Panda';\n```\n\n#### 23.5 不要保存引用this， 用箭头函数或函数绑定——Function#bind.\n\n```javascript\n// bad\nfunction foo() {\n  const self = this;\n  return function () {\n    console.log(self);\n  };\n}\n\n// bad\nfunction foo() {\n  const that = this;\n  return function () {\n    console.log(that);\n  };\n}\n\n// good\nfunction foo() {\n  return () => {\n    console.log(this);\n  };\n}\n```\n\n#### 23.6 export default导出模块A，则这个文件名也叫A.*， import 时候的参数也叫A。 大小写完全一致。\n\n```javascript\n// file 1 contents\nclass CheckBox {\n  // ...\n}\nexport default CheckBox;\n\n// file 2 contents\nexport default function fortyTwo() { return 42; }\n\n// file 3 contents\nexport default function insideDirectory() {}\n\n// in some other file\n// bad\nimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\nimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\nimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\n\n// bad\nimport CheckBox from './check_box'; // PascalCase import/export, snake_case filename\nimport forty_two from './forty_two'; // snake_case import/filename, camelCase export\nimport inside_directory from './inside_directory'; // snake_case import, camelCase export\nimport index from './inside_directory/index'; // requiring the index file explicitly\nimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\n\n// good\nimport CheckBox from './CheckBox'; // PascalCase export/import/filename\nimport fortyTwo from './fortyTwo'; // camelCase export/import/filename\nimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\n// ^ supports both insideDirectory.js and insideDirectory/index.js\n```\n\n#### 23.7 当你export-default一个函数时，函数名用小驼峰，文件名需要和函数名一致。\n\n```javascript\nfunction makeStyleGuide() {\n  // ...\n}\n\nexport default makeStyleGuide;\n```\n\n#### 23.8 当你export一个结构体/类/单例/函数库/对象 时用大驼峰。\n\n```javascript\nconst AirbnbStyleGuide = {\n  es6: {\n  }\n};\n\nexport default AirbnbStyleGuide;\n```\n\n#### 23.9 简称和缩写应该全部大写或全部小写。\n\n> Why? 名字都是给人读的，不是为了适应电脑的算法的。\n\n```javascript\n// bad\nimport SmsContainer from './containers/SmsContainer';\n\n// bad\nconst HttpRequests = [\n  // ...\n];\n\n// good\nimport SMSContainer from './containers/SMSContainer';\n\n// good\nconst HTTPRequests = [\n  // ...\n];\n\n// also good\nconst httpRequests = [\n  // ...\n];\n\n// best\nimport TextMessageContainer from './containers/TextMessageContainer';\n\n// best\nconst requests = [\n  // ...\n];\n```\n\n#### 23.10 你可以用全大写字母设置静态变量，他需要满足三个条件。\n\n> 1. 导出变量\n> 2. 是 const 定义的， 保证不能被改变\n> 3. 这个变量是可信的，他的子属性都是不能被改变的\n\n> Why? 这是一个附加工具，帮助开发者去辨识一个变量是不是不可变的。\n> - 对于所有的 const 变量呢？ —— 这个是不必要的。大写变量不应该在同一个文件里定义并使用， 它只能用来作为导出变量。 赞同！\n> - 那导出的对象呢？ —— 大写变量处在export的最高级(e.g. EXPORTED_OBJECT.key) 并且他包含的所有子属性都是不可变的。\n\n```javascript\n// bad\nconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\n\n// bad\nexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\n\n// bad\nexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\n\n// ---\n\n// 允许但不够语义化\nexport const apiKey = 'SOMEKEY';\n\n// 在大多数情况下更好\nexport const API_KEY = 'SOMEKEY';\n\n// ---\n\n// bad - 不必要的大写键，没有增加任何语义\nexport const MAPPING = {\n  KEY: 'value'\n};\n\n// good\nexport const MAPPING = {\n  key: 'value'\n};\n```\n\n### Accessors\n\n#### 24.1 不需要使用属性的访问器函数。\n\n#### 24.2 不要使用JavaScript的`getters/setters`，因为他们会产生副作用，并且难以测试、维护和理解。相反的，你可以用 `getVal()`和`setVal('hello')`去创造你自己的accessor函数\n\n```javascript\n// bad\nclass Dragon {\n  get age() {\n    // ...\n  }\n\n  set age(value) {\n    // ...\n  }\n}\n\n// good\nclass Dragon {\n  getAge() {\n    // ...\n  }\n\n  setAge(value) {\n    // ...\n  }\n}\n```\n\n#### 24.3 如果属性/方法是`boolean`， 用 `isVal()` 或 `hasVal()`\n\n```javascript\n// bad\nif (!dragon.age()) {\n  return false;\n}\n\n// good\nif (!dragon.hasAge()) {\n  return false;\n}\n```\n\n#### 24.4 用`get()`和`set()`函数是可以的，但是要一起用\n\n```javascript\nclass Jedi {\n  constructor(options = {}) {\n    const lightsaber = options.lightsaber || 'blue';\n    this.set('lightsaber', lightsaber);\n  }\n\n  set(key, val) {\n    this[key] = val;\n  }\n\n  get(key) {\n    return this[key];\n  }\n}\n```\n\n### Events\n\n#### 25.1 通过哈希而不是原始值向事件装载数据时(不论是DOM事件还是像Backbone事件的很多属性)。 这使得后续的贡献者（程序员）向这个事件装载更多的数据时不用去找或者更新每个处理器。例如：\n\n```javascript\n// bad\n$(this).trigger('listingUpdated', listing.id);\n\n// ...\n\n$(this).on('listingUpdated', (e, listingID) => {\n  // do something with listingID\n});\n```\n\nprefer:\n\n```javascript\n// good\n$(this).trigger('listingUpdated', { listingID: listing.id });\n\n// ...\n\n$(this).on('listingUpdated', (e, data) => {\n  // do something with data.listingID\n});\n```\n\n### jQuery对象\n\n#### 26.1 jQuery对象用$变量表示。\n\n```javascript\n// bad\nconst sidebar = $('.sidebar');\n\n// good\nconst $sidebar = $('.sidebar');\n\n// good\nconst $sidebarBtn = $('.sidebar-btn');\n```\n\n#### 26.2 暂存jQuery查找\n\n```javascript\n// bad\nfunction setSidebar() {\n  $('.sidebar').hide();\n\n  // ...\n\n  $('.sidebar').css({\n    'background-color': 'pink'\n  });\n}\n\n// good\nfunction setSidebar() {\n  const $sidebar = $('.sidebar');\n  $sidebar.hide();\n\n  // ...\n\n  $sidebar.css({\n    'background-color': 'pink'\n  });\n}\n```\n\n#### 26.3 DOM查找用层叠式$('.sidebar ul') 或 父节点 > 子节点 $('.sidebar > ul'). jsPerf\n\n#### 26.4 用jQuery对象查询作用域的find方法查询\n\n```javascript\n// bad\n$('ul', '.sidebar').hide();\n\n// bad\n$('.sidebar').find('ul').hide();\n\n// good\n$('.sidebar ul').hide();\n\n// good\n$('.sidebar > ul').hide();\n\n// good\n$sidebar.find('ul').hide();\n```\n\n### ES5 兼容性\n\n#### 27.1 参考Kangax的ES5兼容性列表.\n\n### ECMAScript 6+ (ES 2015+) Styles\n\n#### 28.1 这是收集到的各种ES6特性的链接\n1. 箭头函数——Arrow Functions\n2. 类——Classes\n3. 对象缩写——Object Shorthand\n4. 对象简写——Object Concise\n5. 对象计算属性——Object Computed Properties\n6. 模板字符串——Template Strings\n7. 解构赋值——Destructuring\n8. 默认参数——Default Parameters\n9. Rest\n10. Array Spreads\n11. Let and Const\n12. 幂操作符——Exponentiation Operator\n13. 迭代器和生成器——Iterators and Generators\n14. 模块——Modules\n\n#### 28.2 不要用TC39 proposals， TC39还没有到 stage 3。\n\n> Why? 它还不是最终版, 他可能还有很多变化，或者被撤销。 我们想要用的是 JavaScript， 提议还不是JavaScript。\n\n### Standard Library\n\n标准库中包含一些功能受损但是由于历史原因遗留的工具类\n\n#### 29.1 用 Number.isNaN 代替全局的 isNaN. eslint: `no-restricted-globals`\n\n> Why? 全局 isNaN 强制把非数字转成数字， 然后对于任何强转后为 NaN 的变量都返回 true 如果你想用这个功能，就显式的用它。\n\n```javascript\n// bad\nisNaN('1.2'); // false\nisNaN('1.2.3'); // true\n\n// good\nNumber.isNaN('1.2.3'); // false\nNumber.isNaN(Number('1.2.3')); // true\n```\n\n#### 29.2 用 Number.isFinite 代替 isFinite. eslint: `no-restricted-globals`\n\n> Why? 理由同上，会把一个非数字变量强转成数字，然后做判断。\n\n```javascript\n// bad\nisFinite('2e3'); // true\n\n// good\nNumber.isFinite('2e3'); // false\nNumber.isFinite(parseInt('2e3', 10)); // true\n```\n\n### Testing\n\n#### 30.1 Yup.\n\n```javascript\nfunction foo() {\n  return true;\n}\n```\n\n#### 30.2 No, but seriously:\n\n- 无论用那个测试框架，你都需要写测试。\n- 尽量去写很多小而美的纯函数，减少突变的发生\n- 小心 stub 和 mock —— 这会让你的测试变得脆弱。\n- 在 Airbnb 首选 mocha。 tape 偶尔被用来测试一些小的，独立的模块。\n- 100%测试覆盖率是我们努力的目标，即便实际上很少达到。\n- 每当你修了一个bug， 都要写一个回归测试。 一个bug修复了，没有回归测试，很可能以后会再次出问题。\n","tags":["javascript"]},{"title":"微信小程序","url":"/2020/09/27/wechat/wei-xin-xiao-cheng-xu-bi-ji/","content":"### 用[flyio](https://github.com/wendux/fly)重新封装请求\n<!-- more -->\n```js\n// 引入flyio库\nconst Fly = require(\"../libs/wx.umd.min\");\nconst fly = new Fly();\nfly.config = {\n  baseURL: <请求父路径>,\n  timeout: <超时时间>,\n  headers: {\n    \"content-type\": \"application/x-www-form-urlencoded\"\n  },\n  // 自定义参数，重新请求次数\n  maxAutoRetries: 3\n};\n\n// 拦截器\nfly.interceptors.request.use((config) => {\n  // 给所有请求添加自定义header\n  config.headers[\"token\"] = wx.getStorageSync(\"token\");\n  return config;\n});\n\n// 响应拦截器\nfly.interceptors.response.use(\n  (response) => {\n    try {\n      // 重新获取token\n      if (response.data.status === 40331) {\n        return refreshToken(response.request);\n      }\n      app.globalData.isUpdate = true;\n      return Promise.resolve(response.data);\n    } catch (e) {\n      console.log(e.message);\n    }\n  },\n  (err) => {\n    if (err.status === 0 || err.status === 1) {\n      // 查询请求连接超时，重试\n      if (err.request.method === \"GET\" && err.request.maxAutoRetries > 0) {\n        err.request.maxAutoRetries--;\n        return fly.request(err.request);\n      }\n    }\n    return Promise.reject(err.response || err);\n  }\n)\n\n/**\n * 刷新token\n * \n * @param {*} request 重新请求配置\n */\nfunction refreshToken(request) {\n  // 锁定请求\n  fly.lock();\n  let newFly = new Fly();\n  newFly.config = fly.config;\n  // 苹果不支持finally\n  return newFly.post(<请求路径>).then((d) => {\n    wx.setStorageSync(\"token\", d.data.data);\n  }).then(() => {\n    // 解锁请求\n    fly.unlock();\n    if (wx.getStorageSync(\"token\")) {\n      // 重新请求\n      return fly.request(request);\n    }\n    return Promise.reject();\n  }).catch(() => {\n    fly.unlock();\n  });\n}\nexport default fly;\n```\n\n### 自动化测试miniprogram-automator + jest\n\n#### 一、安装运行环境\n\n运行环境\n- 安装 Node.js 并且版本大于 8.0\n- 基础库版本为 2.7.3 及以上\n- 开发者工具版本为 1.02.1907232 及以上\n\n使用小程序自动化 SDK，直接执行以下命令：\n```js\nnpm i miniprogram-automator --save-dev\n```\n\n#### 二、微信开发者工具端口开启\n\n1. 任意打开一个小程序进入到微信开发者工具->设置->安全->选择开启服务端口->重新打开开发者工具\n\n2. 开启连接微信开发者工具服务端口对应的自动化端口\n\n在微信开发工具的安装目录下打开命令行工具输入\n```js\n./cli.bat --auto '小程序目录地址' --auto-port 9420\n```\n\n#### 三、编写测试脚本\n\n创建测试脚本`script.test.js`\n```js\nconst automator = require('miniprogram-automator')\n\nautomator.launch({\n  wsEndpoint: 'ws://localhost:9420'\n}).then(async miniProgram => {\n  const page = await miniProgram.reLaunch('/page/component/index')\n  await page.waitFor(500)\n  const element = await page.$('.kind-list-item-hd')\n  console.log(await element.attribute('class'))\n  await element.tap()\n\n  await miniProgram.close()\n})\n```\n\n[微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/quick-start.html)\n\n>注意<br>\n>获取页面组件可以用 `await currentPage.$$('组件名')`\n\n最后执行 node path/to/script.test.js 即可看到输出结果。\n\n#### 四、jest\n\n1. 安装jest\n```js\nnpm i jest -g // 全局安装\nnpm i jest --save-dev // 只在当前项目下安装\n```\n\n> 注意<br>\n> 安装`jest@26.6.3`版本，`node`版本需>= `10.14.2`, 否则会出编译问题<br>\n```js\n} catch {\n        ^\nSyntaxError: Unexpected token {\n    at createScript (vm.js:80:10)\n    at Object.runInThisContext (vm.js:139:10)\n    at Module._compile (module.js:616:28)\n    at Object.Module._extensions..js (module.js:663:10)\n    at Module.load (module.js:565:32)\n    at tryModuleLoad (module.js:505:12)\n    at Function.Module._load (module.js:497:3)\n    at Module.require (module.js:596:17)\n    at require (internal/module.js:11:18)\n    at Object.<anonymous> (D:\\nodejs\\node_global\\node_modules\\jest\\node_modules\\jest-cli\\bin\\jest.js:16:3)\n```\n\n2. 初始化jest\n\n```js\njest init\n```\n\n3. 编写测试脚本\n\n```js\nconst automator = require('miniprogram-automator');\n\ndescribe('自动化测试', () => {\n  let miniProgram;\n\n  // 连接本地测试接口\n  beforeAll(async () => {\n    miniProgram = await automator.connect({\n      wsEndpoint: 'ws://localhost:9420',\n    });\n  });\n\n  // 运行结束后关闭连接\n  afterAll(async () => {\n    miniProgram.disconnect();\n  });\n\n  it('登录, 选择第一个学生', async () => {\n    const currentPage = await miniProgram.reLaunch('/pages/login/index')\n    await currentPage.waitFor(1000)\n    const list = await currentPage.$$('select-student')\n    if (list.length > 0) {\n      const current = await list[0].$$('.left');\n      await current[0].tap();\n      await currentPage.waitFor(1000);\n    }\n  }, 50000);\n});\n```\n\n4. 运行\n\n```js\njest 脚本路径\n```\n\n\n\n","tags":["wechat"]},{"title":"JavaScript高级编程设计","url":"/2020/09/21/javascript/javascript-gao-ji-bian-cheng-she-ji/","content":"## 1. ECMAScript与JavaScript区别\n\nECMAScript是一种脚本语言规范，JavaScript则是ECMAScript的实例。\n*****\n<!-- more -->\n## 2. 变量和类型\n\n### 基本数据类型\n\n* null\n* undefined\n* number\n* string\n* boolean\n* symbol(ES6)\n\n### 引用类型\n\n* object\n* function\n* array\n\n### null和undefined的区别\n\n* null表示\"没有对象\"，即该处不应该有值\n* undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义\n\n### JavaScript对象的底层数据结构是什么\n\n### Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\n\n* 应用: 用来定义对象的唯一属性名\n* 实现:\n```\n  function Symbol(value){\n    var obj = new Map();\n  }\n```\n\n### JavaScript中的变量在内存中的具体存储形式\n\n* 基本类型\n基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问\n* 引用类型\n引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用\n\n### 基本类型对应的内置对象，以及他们之间的装箱拆箱操作\n\n* 内置对象：\nObject是JavaScript 中所有对象的父对象<br>\n数据封装类对象：Object、Array、Boolean、Number 和 String<br>\n其他对象：Function、Math、Date、RegExp、Error。<br>\n特殊的基本包装类型(String、Number、Boolean)<br>\narguments: 只存在于函数内部的一个类数组对象<br>\n\n* 装箱和拆箱\n引用类型有个特殊的基本包装类型，它包括String、Number和Boolean。<br>\n作为字符串的a可以调用方法\n\n* 装箱\n基本数据类型转化为对应的引用数据类型的操作**，装箱分为隐式装箱和显示装箱\n> 在《javascript高级程序设计》中有这样一句话：\n每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。(隐式装箱)\n1. 隐式装箱\n```javascript\nlet a = 'sum';\nlet b = a.indexof('s');\n// 上面代码在后台实际的步骤为：\nlet a = new String('sum');\nlet b = a.indexof('s');\na = null;\n```\n在上面的代码中，a是基本类型，它不是对象，不应该具有方法，js内部进行了一些列处理（装箱)， 使得它能够调用方法。在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。实现机制：\n* 创建String类型的一个实例\n* 在实例上调用指定的方法\n* 销毁这个实例\n2. 显示装箱\n通过内置对象可以对Boolean、Object、String等可以对基本类型显示装箱\n```javascript\nlet a = new String('sum')\n```\n* 拆箱\n拆箱和装箱相反，就是把引用类型转化为基本类型的数据，通常通过引用类型的`valueof()`和`toString()`方法实现\n```javascript\nlet name = new String('sun')\nlet age = new Number(24)\nconsole.log(typeof name) // object\nconsole.log(typeof age) //  object\n// 拆箱操作\nconsole.log(typeof age.valueOf()); // number // 24  基本的数字类型\nconsole.log(typeof name.valueOf()); // string  // 'sun' 基本的字符类型\nconsole.log(typeof age.toString()); // string  // '24' 基本的字符类型\nconsole.log(typeof name.toString()); // string  // 'sun' 基本的字符类型\n```\n\n### 理解值类型和引用类型\n\n### 至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\n\n* typeof:\n```\n缺点： 无法区别对对象和数字、null返回的都是object\n```\n* instanceof: \n```\n\n```\n* constructor:\n\n### 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\n\n* string转number\n```\nvar string = \"string\";\nvar number = string.length;\n```\n\n### 出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\n\n*****\n## 3. 原型和原型链\n* 1.理解原型设计模式以及JavaScript中的原型规则\n\n* 2.instanceof的底层实现原理，手动实现一个instanceof\ninstanceof用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上 \n\n* 4.实现继承的几种方式以及他们的优缺点\n\n* 5.至少说出一种开源项目(如Node)中应用原型继承的案例\n\n* 6.可以描述new一个对象的详细过程，手动实现一个new操作符\n\n* 7.理解es6 class构造以及继承的底层实现原理\n\n*****\n## 4. 作用域和闭包\n* 1.理解词法作用域和动态作用域\n\n* 2.理解JavaScript的作用域和作用域链\n\n* 3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题\n\n* 4.this的原理以及几种不同使用场景的取值\n\n* 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\n\n* 6.理解堆栈溢出和内存泄漏的原理，如何防止\n\n* 7.如何处理循环的异步操作\n\n* 8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理\n\n*****\n## 5. 执行机制\n* 1.为何try里面放return，finally还会执行，理解其内部机制\n\n* 2.JavaScript如何实现异步编程，可以详细描述EventLoop机制\n\n* 3.宏任务和微任务分别有哪些\n\n* 4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法\n\n* 5.使用Promise实现串行\n\n* 6.Node与浏览器EventLoop的差异\n\n* 7.如何在保证页面运行流畅的情况下处理海量数据\n\n*****\n## 6. 语法和API\n* 1.理解ECMAScript和JavaScript的关系\n\n* 2.熟练运用es5、es6提供的语法规范，\n\n* 3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）\n\n* 4.熟练应用map、reduce、filter 等高阶函数解决问题\n\n* 5.setInterval需要注意的点，使用settimeout实现setInterval\n\n* 6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题\n\n* 7.JavaScript异常处理的方式，统一的异常处理方案\n","tags":["book","javascript"]},{"title":"高性能JavaScript","url":"/2020/09/21/javascript/gao-xing-neng-javascript/","tags":["book","javascript"]},{"title":"ECMAScript历年新特性","url":"/2020/09/21/javascript/ecmascript-li-nian-xin-te-xing/","content":"\n### [ES6 入门教程](https://es6.ruanyifeng.com/)\n\n### ES11新特性 (ECMAScript2020)\n<!-- more -->\n\n#### String.prototype.matchAll\n> 引用： https://blog.csdn.net/weixin_41849462/article/details/105813995\n\n`String.prototype.match()`方法仅返回完整的匹配结果，却不会返回特定正则表达式组（Regex groups）的信息, 而`String.prototype.matchAll`它返回的迭代器不仅包括精确的匹配结果，还有全部的正则模式捕获结果。\n\n```javascript\n// match() 方法\nconst text = \"From 2019.01.29 to 2019.01.30\";\n\nconst regexp = /(?<year>\\d{4}).(?<month>\\d{2}).(?<day>\\d{2})/gu;\n\nconst results = text.match(regexp);\n\nconsole.log(results);\n// [ '2019.01.29', '2019.01.30' ]\n```\n\n```javascript\n// matchAll() 方法，可以看到结果的 groups 为命名捕获组\nconst text = \"From 2019.01.29 to 2019.01.30\";\n\nconst regexp = /(?<year>\\d{4}).(?<month>\\d{2}).(?<day>\\d{2})/gu;\n\nconst results = Array.from(text.matchAll(regexp));\n\nconsole.log(results);\n// [\n//   [\n//     '2019.01.29',\n//     '2019',\n//     '01',\n//     '29',\n//     index: 5,\n//     input: 'From 2019.01.29 to 2019.01.30',\n//     groups: [Object: null prototype] { year: '2019', month: '01', day: '29' }\n//   ],\n//   [\n//     '2019.01.30',\n//     '2019',\n//     '01',\n//     '30',\n//     index: 19,\n//     input: 'From 2019.01.29 to 2019.01.30',\n//     groups: [Object: null prototype] { year: '2019', month: '01', day: '30' }\n//   ]\n// ]\n```\n\n#### import()\n\n可以按需获取的动态 `import.` 该类函数格式（它并非继承自 Function.prototype）返回了一个强大的 promise 函数，使得诸如按需引入、可计算模块名以及脚本内计算均成为可能。\n\n```javascript\nconst modulePage = 'page.js'; \n\nimport(modulePage)\n     .then((module) => {\n        module.default();\n     });\n```\n\n```javascript\n(async () => {\n  const helpersModule = 'helpers.js';\n\n  const module = await import(helpersModule)\n  \n  const total = module.sum(2, 2);\n})();\n```\n\n#### BigInt – 任意精度整数\n\nJs 中 Number类型只能安全的表示-(2^53-1)至 2^53-1 范的值，即Number.MINSAFEINTEGER 至Number.MAXSAFEINTEGER，超出这个范围的整数计算或者表示会丢失精度。\n\n```javascript\nvar num = Number.MAX_SAFE_INTEGER;  // -> 9007199254740991\n\nnum = num + 1; // -> 9007199254740992\n\n// 再次加 +1 后无法正常运算\nnum = num + 1; \n// -> 9007199254740992\n\n// 两个不同的值，却返回了true\n9007199254740992 === 9007199254740993 // -> true\n```\n\n为解决此问题，ES2020提供一种新的数据类型：BigInt。使用 BigInt 有两种方式：\n- 在整数字面量后面加n\n\n```javascript\nvar bigIntNum = 9007199254740993n;\n```\n\n- 使用 BigInt 函数\n```javascript\nvar bigIntNum = BigInt(9007199254740);\n\nvar anOtherBigIntNum = BigInt('9007199254740993');\n```\n\nBigInt 是一种新的数据原始（primitive）类型。\n```javascript\ntypeof 9007199254740993n; // -> 'bigint'\n```\n> 注意：尽可能避免通过调用函数 BigInt 方式来实例化超大整型。因为参数的字面量实际也是 Number 类型的一次实例化，超出安全范围的数字，可能会引起精度丢失。\n\n#### Promise.allSettled\n\nPromise.all 缺陷\n\n都知道 Promise.all 具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入 reject 状态。\n\n想象这个场景：你的页面有三个区域，分别对应三个独立的接口数据，使用 Promise.all 来并发三个接口，如果其中任意一个接口服务异常，状态是reject,这会导致页面中该三个区域数据全都无法渲染出来，因为任何 reject 都会进入catch回调, 很明显，这是无法接受的，如下：\n\n```javascript\nPromise.all([\nPromise.reject({\n    code: 500,\n    msg: '服务异常'\n}),\nPromise.resolve({\n    code: 200,\n    list: []\n}),\nPromise.resolve({\n    code: 200,\n    list: []})\n]).then((ret) => {\n// 如果其中一个任务是 reject，则不会执行到这个回调。\n    RenderContent\n        (ret);\n}).catch((error) => {\n// 本例中会执行到这个回调\n// error: {code: 500, msg: \"服务异常\"}\n})\n```\n\n我们需要一种机制，如果并发任务中，无论一个任务正常或者异常，都会返回对应的的状态（fulfilled 或者 rejected）与结果（业务value 或者 拒因 reason），在 then 里面通过 filter 来过滤出想要的业务逻辑结果，这就能最大限度的保障业务当前状态的可访问性，而 Promise.allSettled 就是解决这问题的。\n\n```javascript\nPromise.allSettled([\n  fetch(\"https://api.github.com/users/pawelgrzybek\").then(data => data.json()),\n  fetch(\"https://api.github.com/users/danjordan\").then(data => data.json())\n])\n  .then(result => console.log(`All profile settled`));\n```\n\n#### globalThis\n\n所以在 JavaScript 中，全局的 `this` 到底是什么？在浏览器中它是 window, 在 worker 中它是 self, 在 Node.js 中它是 global, 在… 如今这种混乱终于结束了！感谢 Jordan Harband 为我们带来的 `globalThis` 关键字`。\n\n#### for-in 机制\n\n#### 可选链\n\n可选链 可让我们在查询具有多层级的对象时，不再需要进行冗余的各种前置校验。\n\n日常开发中，我们经常会遇到这种查询\n\n```javascript\nvar name = user && user.info && user.info.name;\n```\n\n又或是这种\n\n```javascript\nvar age = user && user.info && user.info.getAge && user.info.getAge();\n```\n\n这是一种丑陋但又不得不做的前置校验，否则很容易命中 `Uncaught TypeError: Cannot read property… `这种错误，这极有可能让你整个应用挂掉。\n\n用了 Optional Chaining ，上面代码会变成\n\n```javascript\nvar name = user?.info?.name;\nvar age = user?.info?.getAge?.();\n```\n\n可选链中的 `?`表示如果问号左边表达式有值, 就会继续查询问号后面的字段。根据上面可以看出，用可选链可以大量简化类似繁琐的前置校验操作，而且更安全。\n\n#### 空值合并运算符\n\n当我们查询某个属性时，经常会遇到，如果没有该属性就会设置一个默认的值。比如下面代码中查询玩家等级。\n\n```javascript\nvar level = (user.data && user.data.level) || '暂无等级';\n```\n\n在JS中，空字符串、0 等，当进行逻辑操作符判时，会自动转化为 false。在上面的代码里，如果玩家等级本身就是 0 级, 变量 level 就会被赋值 暂无等级 字符串，这是逻辑错误。\n\n```javascript\nvar level = (user.data && user.data.level) || '暂无等级';var level;\n\nif(typeof user.level === 'number') {\n    level = user.level;\n} \nelse if(!user.level) {\n    level = '暂无等级';\n} else{\n    level = user.level;\n}\n```\n\n来看看用空值合并运算符如何处理\n\n```javascript\n// {\n//   \"level\": 0\n// }\nvar level = `${user.level}级`?? '暂无等级';// level -> '0级'\n```\n\n用空值合并运算在逻辑正确的前提下，代码更加简洁。\n空值合并运算符 与 可选链 相结合，可以很轻松处理多级查询并赋予默认值问题。\n\n```javascript\nvar level = user.data?.level ?? '暂无等级';\n```\n\n#### import.meta\n\nimport.meta 提议为当前运行的模块添加了一个特定 host 元数据对象\n\n```javascript\nconsole.log(import.meta.url)\n// file:///Users/pawelgrzybek/main.js\n```\n\n#### export * as ns from “mod”\n\n这是对 ES 规范的有力补充，它允许开发者以新名称导出另一模块的命名空间外部对象。\n\n```javascript\nexport * as ns from \"mod\"\n// file:///Users/pawelgrzybek/main.js\n```\n\n### ES10新特性 (ECMAScript2019)\n\n#### Object.fromEntries()\n\nes8中对象添加了一个entries()静态方法，这个方法返回一个给定对象自身可枚举属性的键值对数组 ，Object.fromEntries()方法与 Object.entries() 正好相对，可以将键值对列表转换为一个对象 。\n\n```javascript\nconst obj = {\n  x: 1,\n  y: 2,\n};\n\nconst entries = Object.entries(obj);\n\nconsole.log(entries);\nconsole.log(Object.fromEntries(entries));\n\n// [[\"x\",1],[\"y\":2]]\n// {x:1,y:2}\n```\n\n只要符合entries结构的都可以使用Object.fromEntries(entries)将键值对列表转换为一个对象，比如Map\n\n#### String.prototype.trimStart()/String.prototype.trimEnd()\n\n- trimStart() /trimLeft()\n\n  trimLeft是trimStart的别名,作用是去掉字符串左边的空格\n\n- trimEnd() / trimRight()\n\n  trimEnd是trimRight的别名,作用是去掉字符串右边的空格\n\n```javascript\nconst str = \"   hello world   \";\nconsole.log(str.trimStart());\nconsole.log(str.trimEnd());\nconsole.log(str.trim());\n\n// \"hello world   \"\n// \"   hello world\"\n// \"hello world\"\n```\n\n#### Array.prototype.flat()/Array.prototype.flatMap()\n\n- Array.prototype.flat()\n\n  flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 。\n\n```javascript\nconst arr = [1, [2, [3, [4, [5, [6, 7], 8], 9]]]];\nconsole.log(arr.flat(1));\nconsole.log(arr.flat(5));\nconsole.log(arr.flat(Infinity));\n\n// [1,2,[3, [4, [5, [6, 7], 8], 9]]]\n// [1,2,3,4,5,6,7,8,9]\n// [1,2,3,4,5,6,7,8,9]\n```\n\n- Array.prototype.flatMap()\n\n  flatMap实质上包含两部分功能，一是map,二是flat\n\n```javascript\nconst numbers = [1, 2, 3];\n\nconsole.log(numbers.map((x) => [x ** 2]).flat());\nconsole.log(numbers.flatMap((x) => [x ** 2]));\n\n// [1,4,9]\n// [1,4,9]\n```\n\n#### Symbol.description\n\n可以通过 description 获取 Symbol 的描述\n\n```javascript\nconst symbol = Symbol(\"symbol\");\nconsole.log(symbol.description); // symbol\nconsole.log(symbol.description === \"symbol\"); // true\n```\n\n在es10以前，我们只能通过调用 Symbol 的 toString() 时才可以读取这个属性\n\n```javascript\nconsole.log(symbol.toString() === \"Symbol(symbol)\");\n```\n\n#### Function.prototype.toString()\n\nFunction.prototype.toString() 方法返回一个表示当前函数源代码的字符串\n\n```javascript\nfunction test(a) {\n  // es10以前不返回注释部分\n  console.log(a);\n}\nconsole.log(test.toString());\n\n// function test(a) {\n//  // es10以前不返回注释部分\n//  console.log(a);\n// }\n```\n\n#### catch Building\n\nes10允许我们在捕获异常时省略catch的参数\n\n```javascript\n// es10以前\ntry {\n  throw new Error();\n} catch (error) {\n  console.log(\"fail\");\n}\n\n// es10\ntry {\n  throw new Error();\n} catch {\n  console.log(\"fail\");\n}\n```\n\n#### JSON扩展\n\n- JSON 内容可以支持包含 U+2028行分隔符 与 U+2029段分隔符\n- 在 ES10 JSON.stringify 会用转义字符的方式来处理 超出范围的 Unicode 展示错误的问题 而非编码的方式\n\n```javascript\nconsole.log(JSON.stringify('\\uD83D\\uDE0E')) // 笑脸\n\n// 单独的\\uD83D其实是个无效的字符串\n// 之前的版本 ，这些字符将替换为特殊字符，而现在将未配对的代理代码点表示为JSON转义序列\nconsole.log(JSON.stringify('\\uD83D')) // \"\\ud83d\"\n```\n\n### ES9新特性(ECMAScript2018)\n\n#### for await of/Symbol.asyncIterator\n\nes6中有一个新特性Iteartor,只要元素符合两个协议：\n\n- 可迭代协议：对象包含Symbol.iterator属性；\n- 迭代器协议：Symbol.iterator属性必须返回一个对象，这个对象包含一个next方法，且next方法也返回一个对象，此对象包含value,done两个属性\n我们就可以使用for…of去遍历这个元素。\n\n我们知道 for…of 可以遍历同步运行的任务，那如果是异步任务呢，如下：\n```javascript\nfunction getPromise(time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(time)\n    }, time)\n  })\n}\n\nconst asyncArr = [getPromise(1000), getPromise(200), getPromise(3000)]\n\nfor (let item of asyncArr) {\n  console.log(item, item.then(res => {\n    console.log(res)\n  }))\n}\n// Promise {<pending>} \n// Promise {<pending>}\n// Promise {<pending>}\n// 200\n// 1000\n// 3000\n```\n\n在上述遍历的过程中可以看到三个任务是同步启动的，我们期望的是一个异步任务执行完，在执行下一个异步任务，然而从输出可以看出不是按任务的执行顺序输出的，这显然不太符合我们的要求，在 es9 中也可以用 for…await…of 来操作：\n\n```javascript\nfunction getPromise(time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({\n        value: time,\n        done: false,\n      });\n    }, time);\n  });\n}\n\nconst asyncArr = [getPromise(1000), getPromise(200), getPromise(3000)];\nasyncArr[Symbol.asyncIterator] = function () {\n  let nextIndex = 0;\n  return {\n    next() {\n      return nextIndex < asyncArr.length\n        ? asyncArr[nextIndex++]\n        : Promise.resolve({\n            value: undefined,\n            done: true,\n          });\n  },\n  };\n};\n\nasync function test() {\n  for await (let item of asyncArr) {\n    console.log(Date.now(), item);\n  }\n}\n\ntest();\n\n// 1594374685156 1000\n// 1594374685157 200\n// 1594374687157 3000\n```\n\n> await需要在async 函数或者 async 生成器里面使用\n\n同步迭代器/异步迭代器\n\n| 类别 | 同步迭代器 | 异步迭代器 |\n| ---- | --------- | --------- |\n| 迭代器协议 | Symbol.iterator | Symbol.asyncIteartor |\n| 遍历 | for…of | for…await…of |\n\n#### 正则的扩展\n\n- dotAll/s\n\n  dotAll模式就是：在正则中使用(.)字符时使用s修饰符可以解决(.)字符不能匹配行终止符的例外\n\n```javascript\nconsole.log(/./.test(1));\nconsole.log(/./.test(\"1\"));\nconsole.log(/./.test(\"\\n\"));\nconsole.log(/./.test(\"\\r\"));\nconsole.log(/./.test(\"\\u{2028}\"));\n// true\n// true\n// false\n// false\n// false\n\n// 使用s修饰符\nconsole.log(/./s.test(1));\nconsole.log(/./s.test(\"1\"));\nconsole.log(/./s.test(\"\\n\"));\nconsole.log(/./s.test(\"\\r\"));\nconsole.log(/./s.test(\"\\u{2028}\"));\n// true\n// true\n// true\n// true\n// true\n```\n\n> 1. （.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符\n>\n> 2. 正则中可以使用的修饰符有i, g, m, y, u, s\n\n- 具名组匹配\n\n```javascript\nconsole.log(\"2020-07-10\".match(/(\\d{4})-(\\d{2})-(\\d{2})/));\n// [\"2020-07-10\", \"2020\", \"07\", \"10\", index: 0, input: \"2020-07-10\", groups: undefined]\n```\n\n按照 match 的语法，没有使用 g 修饰符，所以返回值第一个数值是正则表达式的完整匹配，接下来的第二个值到第四个值是分组匹配（2020, 07, 10）,我们想要获取年月日的时候不得不通过数组的下标去获取，这样显得不灵活。仔细观察 match 返回值还有几个属性，分别是 index、input、groups。\n\n> index [匹配的结果的开始位置]\n>\n> input [匹配的字符串]\n>\n> groups [捕获组]\n\n所谓的具名组匹配就是命名捕获分组：\n\n```javascript\nconsole.log(\"2020-07-10\".match(/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/));\n\n// groups的值\ngroups: {year: \"2020\", month: \"07\", day: \"10\"}\n```\n\n这样我们就可以通过groups及命名分组获取对应的年月日的值了。\n\n- 后行断言\n\n```javascript\nlet test = 'world hello'\nconsole.log(test.match(/(?<=world\\s)hello/))\n```\n\n(?<)是后行断言的符号配合= 、！等使用。\n\n#### 对象的Rest和Spread语法\n\n一个例子对比理解对象的Rest和Spread语法\n\n```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\n\n// 数组合并\nconst arr = [...arr1, ...arr2];\nconsole.log(arr);\n\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2 };\n\n// 对象合并\nconst obj = { ...obj1, ...obj2 };\nconsole.log(obj);\n\n// [1, 2, 3, 4, 5, 6]\n// {a: 1, b: 2}\n```\n\n一句话总结就是(…)运算符在数组中可以怎样使用，在对象就可以怎样使用。\n\n#### Promise.prototype.finally()\n\n不管promise状态如何都会执行的回调函数\n\n```javascript\nnew Promise((resolve, reject) => {\n  resolve(1);\n})\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  })\n  .finally(() => {\n    console.log(\"finally\");\n  });\n// 1\n// promise\n```\n\n#### 带标签的模板字符串扩展\n\nes9 新特性中移除了对 ECMAScript带标签的模板字符串中转义序列的语法限制。 遇到不合法的字符串转义返回undefined，并且从raw上可获取原字符串\n\n```javascript\nfunction foo(str) {\n  console.log(str);\n}\n\nfoo`\\undfdfdf`;\n// es9以前报错\n// es9:[undefined, raw:[\"\\undfdfdf\"]]\n```\n\n### ES8新特性(ECMAScript2017)\n\n#### async/await\n\n> 1. async/await是继es6中promise、generator后又一种更加优雅的异步编程的解决方案\n> \n> 2. async函数是generator函数的语法糖\n\n基本用法:\n\n```javascript\n// 不使用async/await\nfunction getPromise() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(1);\n      resolve(2);\n    }, 1000);\n  });\n}\n\nfunction foo() {\n  const res = getPromise();\n  console.log(res);\n  console.log(3);\n}\n\nfoo();\n// Promise {<pending>}\n// 3\n// 1\n\n// 使用async/await\nasync function foo() {\n  const res = await getPromise();\n  console.log(res);\n  console.log(3);\n}\n\nfoo();\n\n// 1\n// 2\n// 3\n```\n\n由上面两个例子的对比就能发现，async/await可以使异步任务处理起来像是同步任务，这是因为await关键字在执行的时候会停下来，等待异步任务执行完毕(await后面一般跟的是异步任务，否则没有意义)在继续执行同步任务。\n\n更优雅的异步编程的解决方案:\n\n在es6之前我们对于这个过程应该不陌生\n```javascript\najax('xxx/a', res => {\n    console.log(res)\n    ajax('xxx/b', res => {\n        console.log(res)\n        ajax('xxx/c', res => {\n            console.log(res)\n        })\n    })\n})\n```\n\n这种回调之后再回调的调用方式我们称之为“回调地狱”，这种回调方式在日常开发和项目维护当中很让人头疼。我们对比下es6中Promise的处理和es8中的async/await的处理方式就知道了为什么我们称async/await为更优雅的异步编程的解决方案。\n\n```javascript\n// 以下都是模拟接口请求的代码\n// Promise\nfunction getPromise(url) {\n    return new Promise((resolve, reject) => {\n        ajax(url, res => {\n            resolve(res)\n        }, err => {\n            reject(err)\n        })\n    })\n}\n\ngetPromise('xxx/a')\n    .then(res => {\n        console.log(res)\n        return getPromise('xxx/b')\n    }).then(res => {\n        console.log(res)\n        return getPromise('xxx/c')\n    }).then(res => {\n        console.log(res)\n    }).catch(err => {\n        console.log(err)\n    })\n    \n    \n // async/await\n function request(url) {\n    return new Promise(resolve => {\n        ajax(url, res => {\n            resolve(res)\n        })\n    })\n}\nasync function getData() {\n    let res1 = await request('xxx/a')\n    console.log(res1)\n    let res2 = await request('xxx/b')\n    console.log(res2)\n    let res3 = await request('xxx/c')\n    console.log(res3)\n}\ngetData()\n```\n\n从两者的对比可以看出，Promise虽然将回调嵌套回调的方式改成平级调用，但是这种调用方式相比于async/await还是显得繁琐，而且async/await不存在回调。\n\n#### Object.values()/Object.entries()\n\n- Object.values()\n\n  Object.values() 返回一个数组，其元素是在对象上找到的可枚举属性值。\n\n```javascript\nconst obj = {\n  name: \"张三\",\n  age: 18,\n  sex: \"male\",\n}\nconsole.log(Object.values(obj)) // [\"张三\", 18, \"male\"]\n```\n\n- Object.entries\n\n  Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组。\n\n```javascript\nconst obj = {\n  name: \"张三\",\n  age: 18,\n  sex: \"male\",\n}\nconsole.log(Object.entries(obj))\n// [[\"name\", \"张三\"],[\"age\", \"18\"], [\"sex\", \"male\"]]\n```\n\nfor in可以遍历出原型链上的可枚举属性，而Object.keys()/Object.values()/Object.entries()只能遍历自身的可枚举属性\n\n```javascript\nconst obj = {\n  name: \"张三\",\n  age: 18,\n  sex: \"male\",\n}\nObject.prototype.test = \"test\"\n\nfor (let key in obj) {\n  console.log(obj[key])\n}\n//  \"张三\", 18, \"male\",\"test\"\nconsole.log(Object.keys(obj).map(key => obj[key]))\n// [\"张三\", 18, \"male\"]\nconsole.log(Object.values(obj))\n// [\"张三\", 18, \"male\"]\nconsole.log(Object.entries(obj).map(([key, value]) => value))\n// [\"张三\", 18, \"male\"]\n```\n\n如何实现一个Object.values()/Object.entries()\n\n```javascript\nconst obj = {\n  name: \"张三\",\n  age: 18,\n  sex: \"male\",\n}\n// Object.values\nfunction values(obj) {\n  return Object.keys(obj).map(key => obj[key])\n}\n\n// Object.entries\nfunction entries(obj) {\n  return Object.keys(obj).map(key => [key, obj[key]])\n}\n\nconsole.log(values(obj)) \nconsole.log(entries(obj))\n```\n\n#### Object.getOwnPropertyDescriptors()\n\nObject.defineProperty()可以通过对描述符的设置进行更精准的控制对象属性，所谓描述符：\n\n1. value [属性的值]\n2. writable [属性的值是否可被改变]\n3. enumerable [属性的值是否可被枚举]\n4. configurable [描述符本身是否可被修改，属性是否可被删除]\n\n```javascript\nvar test = {\n  name: '测试',\n  value: 5\n}\nObject.defineProperty(test, \"name\", {\n  enumerable: false\n})\n\nfor (let key in test) {\n  console.log(key)\n} \n// value\n```\n\n#### Object.getOwnPropertyDescriptors ()\n\nObject.getOwnPropertyDescriptors ()可以返回对象属性的描述符\n\n```javascript\nlet test = {\n  name: '测试',\n  value: 5\n}\nconsole.log(Object.getOwnPropertyDescriptors(test)) \n// {\n//   name: {value: \"测试\", writable: true, enumerable: true, configurable: true}\n//   value: {value: 5, writable: true, enumerable: true, configurable: true}\n// }\n```\n\nObject.getOwnPropertyDescriptors(target,param)接收两个参数,返回某一个参数的描述符，通过这个方法可以实现一个Object.getOwnPropertyDescriptors ()\n\nObject.getOwnPropertyDescriptors()实现\n\n```javascript\nlet test = {\n  name: '测试',\n  value: 5\n}\n\nfunction getOwnPropertyDescriptors(obj) {\n  const result = {};\n  for (let key of Reflect.ownKeys(obj)) {\n    result[key] = Object.getOwnPropertyDescriptor(obj, key);\n  }\n  return result;\n}\ngetOwnPropertyDescriptors(test)\n```\n\n#### String.prototype.padStart()/String.prototype.padEnd()\n\n- padStart()\n  允许将空字符串或其他字符串添加到原始字符串的开头。\n\n```javascript\nconsole.log('13'.padStart(3, '0')); // => 013\nconsole.log('13'.padStart(2, '0')); // => 13\n```\n\n- padEnd()\n  允许将空字符串或其他字符串添加到原始字符串的结尾。\n\n```javascript\nconsole.log('13'.padStart(3, '0')); // => 130\nconsole.log('13'.padStart(2, '0')); // => 13\n```\n\n#### 尾逗号\n\n此前，函数定义和调用时，都不允许最后一个参数后面出现逗号,es8 允许函数的最后一个参数有尾逗号\n\n```javascript\n// es8以前\nfunction foo(a, b, c, d) {\n  console.log(a, b, c, d)\n}\n\n// es8\nfunction foo(a, b, c, d,) {\n  console.log(a, b, c, d)\n}\n```\n\n### ES7新特性(ECMAScript2017)\n\n#### Array.prototype.includes()\n\n判断一个数组是否包含一个元素\n\n```javascript\nconst arr = [\"es6\", \"es7\", \"es8\", \"es9\", \"es10\", \"es11\"，NaN]\nconsole.log(arr.includes(\"es6\"))   // true\nconsole.log(arr.includes(NaN))   // true\nconsole.log(arr.includes(\"es12\"))  // false\n```\n\nincludes的用法和indexOf用法相似，都可以用来判断数组中是否包含一个元素，唯一的区别在于includes可以识别NaN。\n\n> 注意\n> 1. Array.prototype.includes（）：可以接收两个参数，要搜索的值和搜索的开始索引。第二个参数可选，若为负数表示从末尾开始计数下标。\n> 2. 只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些是无法判断的。\n\n#### 幂运算符\n\n```javascript\nconsole.log(2**53)\n```\n\n> 注意\n> 1. 幂运算符的两个*号之间不能出现空格，前后有无空格都可以。\n> 2. 注意最大安全数：Number.MAX_SAFE_INTEGER = (2**53)-1\n\n","tags":["javascript"]},{"title":"CSS世界","url":"/2020/09/18/css/css-shi-jie/","content":"\n","tags":["css","book"]},{"title":"Hexo + Github actions自动部署","url":"/2020/09/17/hexo-github-actions-zi-dong-bu-shu/","content":"### Hexo\n#### 1. 安装Hexo\n```js\nnpm install -g hexo-cli\n```\n<!-- more -->\n#### 2. 初始化Hexo\n```js\nhexo init <folder>\ncd <folder>\nnpm install\n```\n#### 3. 一键部署\n修改根目录下_config.yml 例:\n```yml\n# github部署配置\ndeploy:\n  type: git\n  repo:  git@github.com:<username>/<username>.github.io.git\n  branch: master\n```\n生成站点文件并推送至远程库\n```js\nhexo clean && hexo deploy\n```\n[Hexo文档](https://hexo.io/zh-cn/docs/one-command-deployment)\n\n### Github\n#### 1. 创建库名为<username>.github.io的公共存储库\n#### 2. 配置github密钥\n生成github密钥\n```js\nssh-keygen -t rsa -C \"<user.email>\"\n```\n* `id_rsa.pub` 配置在Settings -> SSH and GPG keys -> New SSH key\n* `id_rsa` 配置在`存储库Settings` -> Secrets -> New Secrets\n\n#### 3. 创建自动部署脚本\n分支安排\n```\n- master: 部署分支\n- pages: 写作分支\n```\n在`pages分支`创建自动部署脚本,只需在`pages分支`创建`.github/workflows/<fileName>.yml`\n\n`<fileName>.yml`文件内容 例：\n```yml\nname: HEXO CI\non: \n  push:\n    branches: [pages]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [10.x]\n    steps:\n      - uses: actions/checkout@v1\n      - name: 配置node环境\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n      - name: 配置github密钥\n        env:\n          HEXO_DEPLOY_PRI: ${{ secrets.HEXO_DEPLOY_PRI }}\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"$HEXO_DEPLOY_PRI\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.name \"<user.name>\"\n          git config --global user.email \"<user.email>\"\n      - name: 安装依赖\n        run: |\n          npm i -g hexo-cli\n          npm i -g hexo-deployer-git\n          npm install\n      - name: 发布页面\n        run: |\n          hexo clean\n          hexo d --config _config.yml\n```\n#### 4.错误问题\n1.问题：引用的样式没有自动部署<br>\n原因：git clone <remoteUrl> themes/<主题名>下载的目录中有隐藏的.git文件，导致git push时该目录下的文件不能添加<br>\n解决方法：删除.git文件\n\n2.问题：git@github.com: Permission denied (publickey)\n原因：github权限问题\n解决方法：检查github密钥是否正确\n\n\n","tags":["hexo","github"]}]